"use strict";(self.webpackChunkcrabsama_blog=self.webpackChunkcrabsama_blog||[]).push([[9877],{5731:(a,e,n)=>{n.r(e),n.d(e,{data:()=>t});const t={key:"v-0db5ca4a",path:"/HTML/prefetch-preload.html",title:"prefetch和preload",lang:"zh-CN",frontmatter:{title:"prefetch和preload",date:"2020-08-13T03:33:02.000Z",lastUpdated:!0,categories:["HTML"]},excerpt:"",headers:[{level:2,title:"preload 提前加载",slug:"preload-提前加载",children:[]},{level:2,title:"prefetch 预判加载",slug:"prefetch-预判加载",children:[]},{level:2,title:"更多细节点",slug:"更多细节点",children:[]}],git:{createdTime:1656301772e3,updatedTime:1656301772e3,contributors:[{name:"CrabSAMA",email:"71915282@qq.com",commits:1}]},filePathRelative:"HTML/prefetch-preload.md"}},7283:(a,e,n)=>{n.r(e),n.d(e,{default:()=>d});var t=n(6252);const s={href:"https://www.nowcoder.com/test/question/done?tid=35895019&qid=643152#summary",target:"_blank",rel:"noopener noreferrer"},o=(0,t.Uk)("牛客真题"),p={href:"https://zhuanlan.zhihu.com/p/48521680",target:"_blank",rel:"noopener noreferrer"},c=(0,t.Uk)("知乎解析"),r=(0,t.uE)('<h2 id="preload-提前加载" tabindex="-1"><a class="header-anchor" href="#preload-提前加载" aria-hidden="true">#</a> <strong>preload 提前加载</strong></h2><p><code>preload</code>顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用时立即执行，无需等待网络的消耗。 <strong>当浏览器解析到这行代码就会去加载 href 中对应的资源</strong>，但不执行，待到真正使用到的时候再执行。</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token comment">&lt;!-- 使用 link 标签静态标记需要预加载的资源 --&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/path/to/style.css<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>style<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="prefetch-预判加载" tabindex="-1"><a class="header-anchor" href="#prefetch-预判加载" aria-hidden="true">#</a> <strong>prefetch 预判加载</strong></h2><p><code>prefetch</code> 跟 <code>preload</code> 不同，它的作用是告诉浏览器未来可能会使用到的某个资源，<strong>浏览器就会在闲时去加载对应的资源</strong>，若能预测到用户端的行为，比如懒加载，点击到其他页面等则相当于提前预加载了需要的资源。</p><div class="language-html ext-html line-numbers-mode"><pre class="language-html"><code><span class="token comment">&lt;!-- link 模式 --&gt;</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/path/to/style.css<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>style<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="更多细节点" tabindex="-1"><a class="header-anchor" href="#更多细节点" aria-hidden="true">#</a> <strong>更多细节点</strong></h2><p>当一个资源被 <code>preload</code> 或者 <code>prefetch</code> 获取后，它将被放在内存缓存中等待被使用，如果资源位存在有效的缓存击中（如 <code>cache-control</code> 或 <code>max-age</code>），它将被存储在 <code>HTTP</code> 缓存中可以被不同页面所使用。 正确使用 <code>preload</code>/<code>prefetch</code> 不会造成二次下载，也就说：<strong>当页面上使用到这个资源时候 <code>preload</code> 资源还没下载完，这时候不会造成二次下载，会等待第一次下载并执行脚本</strong>。 <strong>对于 <code>preload</code> 来说，一旦页面关闭了，它就会立即停止 <code>preload</code> 获取资源，而对于 <code>prefetch</code> 资源，即使页面关闭，<code>prefetch</code> 发起的请求仍会进行不会中断。</strong></p><p><strong>preload</strong> 是告诉浏览器页面必定需要的资源，浏览器<strong>一定会加载</strong>这些资源，而 <strong><code>prefetch</code></strong> 是告诉浏览器页面可能需要的资源，浏览器<strong>不一定会加载</strong>这些资源。所以建议：对于当前页面很有必要的资源使用 <code>preload</code>，对于可能在将来的页面中使用的资源使用 <code>prefetch</code>。</p>',9),l={},d=(0,n(3744).Z)(l,[["render",function(a,e){const n=(0,t.up)("ExternalLinkIcon");return(0,t.wg)(),(0,t.iD)(t.HY,null,[(0,t._)("p",null,[(0,t._)("a",s,[o,(0,t.Wm)(n)]),(0,t._)("a",p,[c,(0,t.Wm)(n)])]),r],64)}]])}}]);