"use strict";(self.webpackChunkcrabsama_blog=self.webpackChunkcrabsama_blog||[]).push([[6351],{7684:(e,n,a)=>{a.r(n),a.d(n,{data:()=>o});const o={key:"v-387be4d4",path:"/%E5%AE%9E%E9%99%85%E9%A1%B9%E7%9B%AE/nginx-reverse-proxy.html",title:"使用 nginx 实现反向代理",lang:"zh-CN",frontmatter:{title:"使用 nginx 实现反向代理",date:"2022-05-27T09:12:22.000Z",lastUpdated:!0,categories:["实际项目"]},excerpt:"",headers:[{level:2,title:"背景",slug:"背景",children:[]},{level:2,title:"实操",slug:"实操",children:[]}],git:{createdTime:1653648648e3,updatedTime:1653648648e3,contributors:[{name:"CrabSAMA",email:"71915282@qq.com",commits:1}]},filePathRelative:"实际项目/nginx-reverse-proxy.md"}},1447:(e,n,a)=>{a.r(n),a.d(n,{default:()=>d});const o=(0,a(6252).uE)('<h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h2><p>在日常开发中，一般 <code>Vue</code> 有两种方式解决跨域问题，一是使用 <code>Vue dev server</code> 中的 <code>proxyTable</code> 选项，搭建本地的反向代理服务器，解决跨域；二是与后端小伙伴沟通，让其允许跨域。</p><p>但是这是在开发过程中，如果后端小伙伴不想开放跨域，然而我们确实是前后端分离部署会触发到同源策略的话，这下就需要我们搭建基于服务器上的反向代理。</p><p>在此之前，我们需要先搞明白一个概念，跨域安全策略是浏览器的一种安全策略，它会将不属于同一个源下的请求 block 掉，其实可以理解成，请求已经发送出去并且服务器已经做出响应，只是被浏览器这个中间人拦截下来了，因为它觉得这是不安全的请求。</p><p>既然知道了这是浏览器的一种策略，那么在之前疑惑的一个问题也顺理成章地得到回答了：<strong>为什么使用</strong> <strong><code>postman</code></strong> **等工具请求接口不会触发跨域？**很明显，因为这些工具不是浏览器环境，只有在浏览器环境下才会触发跨域，服务器与服务器之间请求是不会触发跨域的。</p><p>现在流行的 <code>html</code> 服务器有 <code>apache</code>、<code>nginx</code> 等，这次就以 <code>nginx</code> 为例，说明一下如何搭建反向代理，可以解决跨域问题、由于 <code>chrome</code> 更新后安全策略提高导致的 same-site: Lax 问题等。</p><h2 id="实操" tabindex="-1"><a class="header-anchor" href="#实操" aria-hidden="true">#</a> 实操</h2><p>我们需要找到 <code>nginx</code> 的安装目录，进入其 <code>conf</code> 文件夹，打开 <code>nginx.conf</code> 配置文件。</p><p>找到 <code>location / { … }</code> 这一行，这里是代理默认请求到 <code>index.html</code> ，很符合 <code>Vue</code> 打包出来的 <code>SPA</code> 项目逻辑（一切请求指向 <code>index.html</code>，剩下路由等问题由 <code>Vue</code> 进行处理）。那么我们想要做的是，将 api 请求重定向到后端的服务器，因此这个代理是应该在最上层的，所以我们需要在刚刚的那一行上面，添加这样的配置：</p><div class="language-nginx ext-nginx line-numbers-mode"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">location</span> /api</span> <span class="token punctuation">{</span>\n   <span class="token directive"><span class="token keyword">proxy_pass</span> http://xxx:8080</span><span class="token punctuation">;</span>  <span class="token comment">#node api server 即需要代理的IP地址</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>这里的配置意思是，将请求到 <code>localhost/api/…</code> 的所有请求，转发到 <code>proxy_pass</code> 这个地址去，并且由 <code>nginx</code> 获取到响应后的结果进行返回。在做完这个之后，其实反向代理已经搭建完成了。还有其他一系列的一些其他配置，可以给请求头 / 响应头添加一些便于交流的属性，这个可以在 <code>nginx</code> 的配置文档中看到，此处就不做描述，有兴趣可以了解一下。</p><p>前端在搭建完成后，还需要将原本项目中的绝对地址的请求（eg: http://xxx:8080/api/login） 转换为相对地址的请求（即 <code>/api/login</code>，请求到 <code>localhost/api/login</code>），这样 <code>nginx</code> 就会成功代理到我们的请求并转发到后端服务器。</p>',12),c={},d=(0,a(3744).Z)(c,[["render",function(e,n){return o}]])}}]);