import{_ as o,c as d,i as c,o as t}from"./app-DOF6gB1w.js";const n={};function r(a,e){return t(),d("div",null,e[0]||(e[0]=[c("<ul><li><p>问： 为什么通过<code>headers</code>对象访问到的<code>HTTP</code>请求头或响应头字段不是驼峰的？<br> 答： 从规范上讲，HTTP<code>请求</code>头和响应头字段都应该是驼峰的。但现实是残酷的，不是每个 HTTP<code>服务</code>端或客户端程序都严格遵循规范，所以<code>NodeJS</code>在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如<code>headers[&#39;content-length&#39;]</code>。</p></li><li><p>问： 为什么<code>http</code>模块创建的<code>HTTP</code>服务器返回的响应是<code>chunked</code>传输方式的？<br> 答： 因为默认情况下，使用<code>.writeHead</code>方法写入响应头后，允许使用<code>.write</code>方法写入任意长度的响应体数据，并使用.end 方法结束一个响应。由于响应体数据长度不确定，因此<code>NodeJS</code>自动在响应头里添加了<code>Transfer-Encoding: chunked</code>字段，并采用<code>chunked</code>传输方式。但是当响应体数据长度确定时，可使用<code>.writeHead</code>方法在响应头里加上<code>Content-Length</code>字段，这样做之后<code>NodeJS</code>就不会自动添加<code>Transfer-Encoding</code>字段和使用<code>chunked</code>传输方式。</p></li><li><p>问： 为什么使用<code>http</code>模块发起<code>HTTP</code>客户端请求时，有时候会发生<code>socket hang up</code>错误？<br> 答： 发起客户端<code>HTTP</code>请求前需要先创建一个客户端。<code>http</code>模块提供了一个全局客户端<code>http.globalAgent</code>，可以让我们使用<code>.request</code>或<code>.get</code>方法时不用手动创建客户端。但是全局客户端默认只允许 5 个并发<code>Socket</code>连接，当某一个时刻<code>HTTP</code>客户端请求创建过多，超过这个数字时，就会发生<code>socket hang up</code>错误。解决方法也很简单，通过<code>http.globalAgent.maxSockets</code>属性把这个数字改大些即可。另外，<code>https</code>模块遇到这个问题时也一样通过 https.globalAgent.maxSockets 属性来处理。</p></li></ul>",1)]))}const p=o(n,[["render",r]]),i=JSON.parse(`{"path":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node-http-requests-and-responses.html","title":"Node.js 操作HTTP请求和响应的常见问题","lang":"zh-CN","frontmatter":{"title":"Node.js 操作HTTP请求和响应的常见问题","date":"2020-07-09T07:53:34.000Z","category":["学习笔记"],"tag":["Node.js"],"description":"问： 为什么通过headers对象访问到的HTTP请求头或响应头字段不是驼峰的？ 答： 从规范上讲，HTTP请求头和响应头字段都应该是驼峰的。但现实是残酷的，不是每个 HTTP服务端或客户端程序都严格遵循规范，所以NodeJS在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如header...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Node.js 操作HTTP请求和响应的常见问题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-07-09T07:53:34.000Z\\",\\"dateModified\\":\\"2024-09-29T07:33:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CrabSAMA\\",\\"url\\":\\"https://crabsama.github.io/CrabSAMA-Blog\\"}]}"],["meta",{"property":"og:url","content":"https://crabsama.github.io/CrabSAMA-Blog/CrabSAMA-Blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/node-http-requests-and-responses.html"}],["meta",{"property":"og:site_name","content":"CrabSAMA · 笔记"}],["meta",{"property":"og:title","content":"Node.js 操作HTTP请求和响应的常见问题"}],["meta",{"property":"og:description","content":"问： 为什么通过headers对象访问到的HTTP请求头或响应头字段不是驼峰的？ 答： 从规范上讲，HTTP请求头和响应头字段都应该是驼峰的。但现实是残酷的，不是每个 HTTP服务端或客户端程序都严格遵循规范，所以NodeJS在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如header..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-29T07:33:27.000Z"}],["meta",{"property":"article:tag","content":"Node.js"}],["meta",{"property":"article:published_time","content":"2020-07-09T07:53:34.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-29T07:33:27.000Z"}]]},"git":{"createdTime":1655211700000,"updatedTime":1727595207000,"contributors":[{"name":"CrabSAMA","username":"CrabSAMA","email":"71915282@qq.com","commits":9,"url":"https://github.com/CrabSAMA"}]},"readingTime":{"minutes":1.74,"words":522},"filePathRelative":"学习笔记/node-http-requests-and-responses.md","excerpt":"<ul>\\n<li>\\n<p>问： 为什么通过<code>headers</code>对象访问到的<code>HTTP</code>请求头或响应头字段不是驼峰的？<br>\\n答： 从规范上讲，HTTP<code>请求</code>头和响应头字段都应该是驼峰的。但现实是残酷的，不是每个 HTTP<code>服务</code>端或客户端程序都严格遵循规范，所以<code>NodeJS</code>在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如<code>headers['content-length']</code>。</p>\\n</li>\\n<li>\\n<p>问： 为什么<code>http</code>模块创建的<code>HTTP</code>服务器返回的响应是<code>chunked</code>传输方式的？<br>\\n答： 因为默认情况下，使用<code>.writeHead</code>方法写入响应头后，允许使用<code>.write</code>方法写入任意长度的响应体数据，并使用.end 方法结束一个响应。由于响应体数据长度不确定，因此<code>NodeJS</code>自动在响应头里添加了<code>Transfer-Encoding: chunked</code>字段，并采用<code>chunked</code>传输方式。但是当响应体数据长度确定时，可使用<code>.writeHead</code>方法在响应头里加上<code>Content-Length</code>字段，这样做之后<code>NodeJS</code>就不会自动添加<code>Transfer-Encoding</code>字段和使用<code>chunked</code>传输方式。</p>\\n</li>\\n<li>\\n<p>问： 为什么使用<code>http</code>模块发起<code>HTTP</code>客户端请求时，有时候会发生<code>socket hang up</code>错误？<br>\\n答： 发起客户端<code>HTTP</code>请求前需要先创建一个客户端。<code>http</code>模块提供了一个全局客户端<code>http.globalAgent</code>，可以让我们使用<code>.request</code>或<code>.get</code>方法时不用手动创建客户端。但是全局客户端默认只允许 5 个并发<code>Socket</code>连接，当某一个时刻<code>HTTP</code>客户端请求创建过多，超过这个数字时，就会发生<code>socket hang up</code>错误。解决方法也很简单，通过<code>http.globalAgent.maxSockets</code>属性把这个数字改大些即可。另外，<code>https</code>模块遇到这个问题时也一样通过 https.globalAgent.maxSockets 属性来处理。</p>\\n</li>\\n</ul>","autoDesc":true}`);export{p as comp,i as data};
