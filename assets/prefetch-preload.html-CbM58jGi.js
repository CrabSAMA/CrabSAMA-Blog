import{_ as t,c as i,i as a,o as s}from"./app-CNzJ7I-c.js";const r={};function o(n,e){return s(),i("div",null,e[0]||(e[0]=[a(`<p><a href="https://www.nowcoder.com/test/question/done?tid=35895019&amp;qid=643152#summary" target="_blank" rel="noopener noreferrer">牛客真题</a><br><a href="https://zhuanlan.zhihu.com/p/48521680" target="_blank" rel="noopener noreferrer">知乎解析</a></p><h2 id="preload-提前加载" tabindex="-1"><a class="header-anchor" href="#preload-提前加载"><span><strong>preload 提前加载</strong></span></a></h2><p><code>preload</code>顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用时立即执行，无需等待网络的消耗。<br><strong>当浏览器解析到这行代码就会去加载 href 中对应的资源</strong>，但不执行，待到真正使用到的时候再执行。</p><div class="language-html line-numbers-mode" data-highlighter="shiki" data-ext="html" data-title="html" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">&lt;!-- 使用 link 标签静态标记需要预加载的资源 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">link</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> rel</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;preload&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> href</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;/path/to/style.css&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> as</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;style&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="prefetch-预判加载" tabindex="-1"><a class="header-anchor" href="#prefetch-预判加载"><span><strong>prefetch 预判加载</strong></span></a></h2><p><code>prefetch</code> 跟 <code>preload</code> 不同，它的作用是告诉浏览器未来可能会使用到的某个资源，<strong>浏览器就会在闲时去加载对应的资源</strong>，若能预测到用户端的行为，比如懒加载，点击到其他页面等则相当于提前预加载了需要的资源。</p><div class="language-html line-numbers-mode" data-highlighter="shiki" data-ext="html" data-title="html" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">&lt;!-- link 模式 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">link</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> rel</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;prefetch&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> href</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;/path/to/style.css&quot;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> as</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;style&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="更多细节点" tabindex="-1"><a class="header-anchor" href="#更多细节点"><span><strong>更多细节点</strong></span></a></h2><p>当一个资源被 <code>preload</code> 或者 <code>prefetch</code> 获取后，它将被放在内存缓存中等待被使用，如果资源位存在有效的缓存击中（如 <code>cache-control</code> 或 <code>max-age</code>），它将被存储在 <code>HTTP</code> 缓存中可以被不同页面所使用。<br> 正确使用 <code>preload</code>/<code>prefetch</code> 不会造成二次下载，也就说：<strong>当页面上使用到这个资源时候 <code>preload</code> 资源还没下载完，这时候不会造成二次下载，会等待第一次下载并执行脚本</strong>。<br><strong>对于 <code>preload</code> 来说，一旦页面关闭了，它就会立即停止 <code>preload</code> 获取资源，而对于 <code>prefetch</code> 资源，即使页面关闭，<code>prefetch</code> 发起的请求仍会进行不会中断。</strong></p><p><strong>preload</strong> 是告诉浏览器页面必定需要的资源，浏览器<strong>一定会加载</strong>这些资源，而 <strong><code>prefetch</code></strong> 是告诉浏览器页面可能需要的资源，浏览器<strong>不一定会加载</strong>这些资源。所以建议：对于当前页面很有必要的资源使用 <code>preload</code>，对于可能在将来的页面中使用的资源使用 <code>prefetch</code>。</p>`,10)]))}const h=t(r,[["render",o],["__file","prefetch-preload.html.vue"]]),p=JSON.parse('{"path":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/prefetch-preload.html","title":"prefetch和preload","lang":"zh-CN","frontmatter":{"title":"prefetch和preload","date":"2020-08-13T03:33:02.000Z","category":["学习笔记"],"tag":["HTML","性能优化","面试题"],"description":"牛客真题 知乎解析 preload 提前加载 preload顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用时立即执行，无需等待网络的消耗。 当浏览器解析到这行代码就会去加载 href 中对应的资源，但不执行，待到真正使用到的时候再执行。 prefetch 预判加载 prefetch 跟 preload 不同...","head":[["meta",{"property":"og:url","content":"https://crabsama.github.io/CrabSAMA-Blog/CrabSAMA-Blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/prefetch-preload.html"}],["meta",{"property":"og:site_name","content":"CrabSAMA · 笔记"}],["meta",{"property":"og:title","content":"prefetch和preload"}],["meta",{"property":"og:description","content":"牛客真题 知乎解析 preload 提前加载 preload顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用时立即执行，无需等待网络的消耗。 当浏览器解析到这行代码就会去加载 href 中对应的资源，但不执行，待到真正使用到的时候再执行。 prefetch 预判加载 prefetch 跟 preload 不同..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-17T14:39:26.000Z"}],["meta",{"property":"article:author","content":"CrabSAMA"}],["meta",{"property":"article:tag","content":"HTML"}],["meta",{"property":"article:tag","content":"性能优化"}],["meta",{"property":"article:tag","content":"面试题"}],["meta",{"property":"article:published_time","content":"2020-08-13T03:33:02.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-17T14:39:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"prefetch和preload\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-08-13T03:33:02.000Z\\",\\"dateModified\\":\\"2024-08-17T14:39:26.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CrabSAMA\\",\\"url\\":\\"https://crabsama.github.io/CrabSAMA-Blog\\"}]}"]]},"headers":[{"level":2,"title":"preload 提前加载","slug":"preload-提前加载","link":"#preload-提前加载","children":[]},{"level":2,"title":"prefetch 预判加载","slug":"prefetch-预判加载","link":"#prefetch-预判加载","children":[]},{"level":2,"title":"更多细节点","slug":"更多细节点","link":"#更多细节点","children":[]}],"git":{"createdTime":1656301166000,"updatedTime":1723905566000,"contributors":[{"name":"CrabSAMA","email":"71915282@qq.com","commits":4}]},"readingTime":{"minutes":1.85,"words":555},"filePathRelative":"学习笔记/prefetch-preload.md","localizedDate":"2020年8月13日","excerpt":"<p><a href=\\"https://www.nowcoder.com/test/question/done?tid=35895019&amp;qid=643152#summary\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">牛客真题</a><br>\\n<a href=\\"https://zhuanlan.zhihu.com/p/48521680\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">知乎解析</a></p>\\n<h2><strong>preload 提前加载</strong></h2>\\n<p><code>preload</code>顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用时立即执行，无需等待网络的消耗。<br>\\n<strong>当浏览器解析到这行代码就会去加载 href 中对应的资源</strong>，但不执行，待到真正使用到的时候再执行。</p>","autoDesc":true}');export{h as comp,p as data};
