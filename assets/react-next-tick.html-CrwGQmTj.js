import{_ as i,c as a,i as t,o as e}from"./app-BZaFnBl_.js";const n={};function l(h,s){return e(),a("div",null,s[0]||(s[0]=[t(`<h1 id="react-实现类似-nexttick-功能" tabindex="-1"><a class="header-anchor" href="#react-实现类似-nexttick-功能"><span>React 实现类似 nextTick 功能</span></a></h1><p>作为一个 Vue 开发，在学习与使用 React 进行开发的时候，很自然地就会代入一些 Vue 的思想。在 Vue 和 React 中更新状态都是异步的，即更新完状态 DOM 并不会马上进行更新，而是在之后的某个时机才会进行状态更新并更新 DOM。</p><p>在 Vue 里面，我们有 nextTick 这种方法，可以保证在状态更新完成后执行一些业务逻辑。但在使用 React 的初期，我并没有发现有这种类似的 API。</p><p>react 如何实现类似 nexttick 这种方法？就是保证 setState 执行完成后才执行，举例：赋值完成后滚动到底部。</p><h2 id="最初的解法-使用-useeffect" tabindex="-1"><a class="header-anchor" href="#最初的解法-使用-useeffect"><span>最初的解法：使用 useEffect</span></a></h2><p>在 useEffect 中，当状态发生更新时会执行对应的回调函数。在这里面我们可以保证状态已经更新完成，因此我们可以将滚动到底部的逻辑放在里面执行。</p><p>但很快我就遇到了难题：nextTick 是自由的，我们可以在需要执行业务逻辑的时候调用 nextTick，但是将逻辑放在了 useEffect 中，每次状态更新都会触发我们的业务逻辑。在这个时候，参考了 gpt 提供的一些方案，使用了一个 flag 来控制业务逻辑的执行。</p><div class="language-tsx line-numbers-mode" data-highlighter="shiki" data-ext="tsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-tsx"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 只有在第一次请求数据的时候需要滚动到底部</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">let</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> scrollFlag</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">useEffect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">scrollFlag</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &amp;&amp;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> chatHistory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">length</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> &gt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    scrollFlag</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> false</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    scrollToBottom</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}, [</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">chatHistory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> setScrollFlag</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">flag</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> boolean</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">scrollFlag</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> flag</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方法可以实现到类似的效果，但是并不优雅，并且在使用过程中经常遇到 flag 忘记更新的情况，使用起来心智负担也比较大，因此我也在找寻更加高效优雅的方案。</p><h2 id="官方正解-flushsync" tabindex="-1"><a class="header-anchor" href="#官方正解-flushsync"><span>官方正解：flushSync</span></a></h2><p><a href="https://zh-hans.react.dev/learn/manipulating-the-dom-with-refs#flushing-state-updates-synchronously-with-flush-sync" target="_blank" rel="noopener noreferrer">情景演示</a></p><p><a href="https://zh-hans.react.dev/reference/react-dom/flushSync" target="_blank" rel="noopener noreferrer">https://zh-hans.react.dev/reference/react-dom/flushSync</a></p><p>使用 flushSync，在 flushSync 回调函数中执行的代码会马上更新视图。</p><div class="language-tsx line-numbers-mode" data-highlighter="shiki" data-ext="tsx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-tsx"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">chatHistory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;">setChatHistory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> useState</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">ChatHistoryItem</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[]&gt;([])</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> flushSetChatHistory</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  flushSync</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // @ts-ignore</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    setChatHistory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  })</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> setChatHistoryAndScroll</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  flushSetChatHistory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">...</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">args</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  scrollToBottom</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于需要更新状态后视图更新才能滚动到底部，因此这里做了一个 <code>flushSetChatHistory</code> 的封装，实际运行效果没问题。</p><p>最终我们实现了对应的效果：在需要实时更新状态的情况下，我们使用 <code>flushSetChatHistory</code> 函数，而在不需要实时更新状态的情况下，我们使用默认的 <code>setChatHistory</code> 函数即可。</p>`,16)]))}const p=i(n,[["render",l]]),r=JSON.parse('{"path":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/react-next-tick.html","title":"React实现类似nextTick功能","lang":"zh-CN","frontmatter":{"title":"React实现类似nextTick功能","date":"2024-08-01T09:46:35.000Z","category":["学习笔记"],"tag":["React"],"description":"React 实现类似 nextTick 功能 作为一个 Vue 开发，在学习与使用 React 进行开发的时候，很自然地就会代入一些 Vue 的思想。在 Vue 和 React 中更新状态都是异步的，即更新完状态 DOM 并不会马上进行更新，而是在之后的某个时机才会进行状态更新并更新 DOM。 在 Vue 里面，我们有 nextTick 这种方法，可以...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React实现类似nextTick功能\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-01T09:46:35.000Z\\",\\"dateModified\\":\\"2024-09-29T07:33:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CrabSAMA\\",\\"url\\":\\"https://crabsama.github.io/CrabSAMA-Blog\\"}]}"],["meta",{"property":"og:url","content":"https://crabsama.github.io/CrabSAMA-Blog/CrabSAMA-Blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/react-next-tick.html"}],["meta",{"property":"og:site_name","content":"CrabSAMA · 笔记"}],["meta",{"property":"og:title","content":"React实现类似nextTick功能"}],["meta",{"property":"og:description","content":"React 实现类似 nextTick 功能 作为一个 Vue 开发，在学习与使用 React 进行开发的时候，很自然地就会代入一些 Vue 的思想。在 Vue 和 React 中更新状态都是异步的，即更新完状态 DOM 并不会马上进行更新，而是在之后的某个时机才会进行状态更新并更新 DOM。 在 Vue 里面，我们有 nextTick 这种方法，可以..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-29T07:33:27.000Z"}],["meta",{"property":"article:tag","content":"React"}],["meta",{"property":"article:published_time","content":"2024-08-01T09:46:35.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-29T07:33:27.000Z"}]]},"git":{"createdTime":1724313559000,"updatedTime":1727595207000,"contributors":[{"name":"CrabSAMA","username":"CrabSAMA","email":"71915282@qq.com","commits":2,"url":"https://github.com/CrabSAMA"}]},"readingTime":{"minutes":2.16,"words":649},"filePathRelative":"学习笔记/react-next-tick.md","excerpt":"\\n<p>作为一个 Vue 开发，在学习与使用 React 进行开发的时候，很自然地就会代入一些 Vue 的思想。在 Vue 和 React 中更新状态都是异步的，即更新完状态 DOM 并不会马上进行更新，而是在之后的某个时机才会进行状态更新并更新 DOM。</p>\\n<p>在 Vue 里面，我们有 nextTick 这种方法，可以保证在状态更新完成后执行一些业务逻辑。但在使用 React 的初期，我并没有发现有这种类似的 API。</p>\\n<p>react 如何实现类似 nexttick 这种方法？就是保证 setState 执行完成后才执行，举例：赋值完成后滚动到底部。</p>\\n<h2>最初的解法：使用 useEffect</h2>","autoDesc":true}');export{p as comp,r as data};
