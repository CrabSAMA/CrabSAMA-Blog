import{_ as t,c as i,i as o,o as n}from"./app-CNzJ7I-c.js";const a={};function r(c,e){return n(),i("div",null,e[0]||(e[0]=[o(`<h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h2><p>在日常开发中，一般 <code>Vue</code> 有两种方式解决跨域问题，一是使用 <code>Vue dev server</code> 中的 <code>proxyTable</code> 选项，搭建本地的反向代理服务器，解决跨域；二是与后端小伙伴沟通，让其允许跨域。</p><p>但是这是在开发过程中，如果后端小伙伴不想开放跨域，然而我们确实是前后端分离部署会触发到同源策略的话，这下就需要我们搭建基于服务器上的反向代理。</p><p>在此之前，我们需要先搞明白一个概念，跨域安全策略是浏览器的一种安全策略，它会将不属于同一个源下的请求 block 掉，其实可以理解成，请求已经发送出去并且服务器已经做出响应，只是被浏览器这个中间人拦截下来了，因为它觉得这是不安全的请求。</p><p>既然知道了这是浏览器的一种策略，那么在之前疑惑的一个问题也顺理成章地得到回答了：<strong>为什么使用</strong> <strong><code>postman</code></strong> **等工具请求接口不会触发跨域？**很明显，因为这些工具不是浏览器环境，只有在浏览器环境下才会触发跨域，服务器与服务器之间请求是不会触发跨域的。</p><p>现在流行的 <code>html</code> 服务器有 <code>apache</code>、<code>nginx</code> 等，这次就以 <code>nginx</code> 为例，说明一下如何搭建反向代理，可以解决跨域问题、由于 <code>chrome</code> 更新后安全策略提高导致的 same-site: Lax 问题等。</p><h2 id="实操" tabindex="-1"><a class="header-anchor" href="#实操"><span>实操</span></a></h2><p>我们需要找到 <code>nginx</code> 的安装目录，进入其 <code>conf</code> 文件夹，打开 <code>nginx.conf</code> 配置文件。</p><p>找到 <code>location / { … }</code> 这一行，这里是代理默认请求到 <code>index.html</code> ，很符合 <code>Vue</code> 打包出来的 <code>SPA</code> 项目逻辑（一切请求指向 <code>index.html</code>，剩下路由等问题由 <code>Vue</code> 进行处理）。那么我们想要做的是，将 api 请求重定向到后端的服务器，因此这个代理是应该在最上层的，所以我们需要在刚刚的那一行上面，添加这样的配置：</p><div class="language-nginx line-numbers-mode" data-highlighter="shiki" data-ext="nginx" data-title="nginx" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">location</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> /api {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   proxy_pass </span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">http://xxx:8080;  </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">#node api server 即需要代理的IP地址</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的配置意思是，将请求到 <code>localhost/api/…</code> 的所有请求，转发到 <code>proxy_pass</code> 这个地址去，并且由 <code>nginx</code> 获取到响应后的结果进行返回。在做完这个之后，其实反向代理已经搭建完成了。还有其他一系列的一些其他配置，可以给请求头 / 响应头添加一些便于交流的属性，这个可以在 <code>nginx</code> 的配置文档中看到，此处就不做描述，有兴趣可以了解一下。</p><p>前端在搭建完成后，还需要将原本项目中的绝对地址的请求（eg: <a href="http://xxx:8080/api/login%EF%BC%89" target="_blank" rel="noopener noreferrer">http://xxx:8080/api/login）</a> 转换为相对地址的请求（即 <code>/api/login</code>，请求到 <code>localhost/api/login</code>），这样 <code>nginx</code> 就会成功代理到我们的请求并转发到后端服务器。</p>`,12)]))}const d=t(a,[["render",r],["__file","nginx-reverse-proxy.html.vue"]]),p=JSON.parse('{"path":"/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/nginx-reverse-proxy.html","title":"使用 nginx 实现反向代理","lang":"zh-CN","frontmatter":{"title":"使用 nginx 实现反向代理","date":"2022-05-27T09:12:22.000Z","category":["解决方案"],"tag":["nginx","计算机网络"],"description":"背景 在日常开发中，一般 Vue 有两种方式解决跨域问题，一是使用 Vue dev server 中的 proxyTable 选项，搭建本地的反向代理服务器，解决跨域；二是与后端小伙伴沟通，让其允许跨域。 但是这是在开发过程中，如果后端小伙伴不想开放跨域，然而我们确实是前后端分离部署会触发到同源策略的话，这下就需要我们搭建基于服务器上的反向代理。 在此...","head":[["meta",{"property":"og:url","content":"https://crabsama.github.io/CrabSAMA-Blog/CrabSAMA-Blog/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/nginx-reverse-proxy.html"}],["meta",{"property":"og:site_name","content":"CrabSAMA · 笔记"}],["meta",{"property":"og:title","content":"使用 nginx 实现反向代理"}],["meta",{"property":"og:description","content":"背景 在日常开发中，一般 Vue 有两种方式解决跨域问题，一是使用 Vue dev server 中的 proxyTable 选项，搭建本地的反向代理服务器，解决跨域；二是与后端小伙伴沟通，让其允许跨域。 但是这是在开发过程中，如果后端小伙伴不想开放跨域，然而我们确实是前后端分离部署会触发到同源策略的话，这下就需要我们搭建基于服务器上的反向代理。 在此..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-17T14:39:40.000Z"}],["meta",{"property":"article:author","content":"CrabSAMA"}],["meta",{"property":"article:tag","content":"nginx"}],["meta",{"property":"article:tag","content":"计算机网络"}],["meta",{"property":"article:published_time","content":"2022-05-27T09:12:22.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-17T14:39:40.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"使用 nginx 实现反向代理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-05-27T09:12:22.000Z\\",\\"dateModified\\":\\"2024-08-17T14:39:40.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CrabSAMA\\",\\"url\\":\\"https://crabsama.github.io/CrabSAMA-Blog\\"}]}"]]},"headers":[{"level":2,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":2,"title":"实操","slug":"实操","link":"#实操","children":[]}],"git":{"createdTime":1653648648000,"updatedTime":1723905580000,"contributors":[{"name":"CrabSAMA","email":"71915282@qq.com","commits":4}]},"readingTime":{"minutes":2.64,"words":792},"filePathRelative":"解决方案/nginx-reverse-proxy.md","localizedDate":"2022年5月27日","excerpt":"<h2>背景</h2>\\n<p>在日常开发中，一般 <code>Vue</code> 有两种方式解决跨域问题，一是使用 <code>Vue dev server</code> 中的 <code>proxyTable</code> 选项，搭建本地的反向代理服务器，解决跨域；二是与后端小伙伴沟通，让其允许跨域。</p>\\n<p>但是这是在开发过程中，如果后端小伙伴不想开放跨域，然而我们确实是前后端分离部署会触发到同源策略的话，这下就需要我们搭建基于服务器上的反向代理。</p>\\n<p>在此之前，我们需要先搞明白一个概念，跨域安全策略是浏览器的一种安全策略，它会将不属于同一个源下的请求 block 掉，其实可以理解成，请求已经发送出去并且服务器已经做出响应，只是被浏览器这个中间人拦截下来了，因为它觉得这是不安全的请求。</p>","autoDesc":true}');export{d as comp,p as data};
