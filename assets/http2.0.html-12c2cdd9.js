import{_ as e,X as o,Y as c,a2 as d}from"./framework-43a12551.js";const a="/CrabSAMA-Blog/assets/image-20220527180211375-fd288f10.png",t="/CrabSAMA-Blog/assets/image-20220527181454485-7bb6a582.png",r="/CrabSAMA-Blog/assets/image-20220527181554326-552b5de9.png",i={},n=d('<p><code>HTTP 2.0</code> 的出现，相比于 <code>HTTP 1.x</code> ，大幅度的提升了 <code>web</code> 性能。在与 HTTP/1.1 完全语义兼容的基础上，进一步减少了网络延迟。</p><p><code>Firefox</code> 和 <code>Chrome</code> 早已宣布不支持任何不经过 <code>TLS</code> 加密的 <code>HTTP/2</code> 协议。</p><h2 id="多路复用" tabindex="-1"><a class="header-anchor" href="#多路复用" aria-hidden="true">#</a> 多路复用</h2><p>多路复用允许同时通过单一的 <code>HTTP/2</code> 连接发起多重请求-响应消息。</p><p>众所周知，在 <code>HTTP/1.1</code> 协议中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。</p><p>这也是为何一些站点有多个静态资源 <code>CDN</code> 域名的原因之一，可以变相地解决浏览器针对同一域名的请求限制阻塞问题。</p><p>而 <code>HTTP/2</code> 的多路复用则允许同时通过<strong>单一的</strong> <strong>HTTP/2</strong> <strong>连接</strong>发起多重的<strong>请求-响应</strong>消息。</p><figure><img src="'+a+'" alt="image-20220527180211375" tabindex="0" loading="lazy"><figcaption>image-20220527180211375</figcaption></figure><p>因此 <code>HTTP/2</code> 可以很容易的去实现多流并行而不用依赖建立多个 <code>TCP</code> 连接，<code>HTTP/2</code> 把 <code>HTTP</code> 协议通信的基本单位缩小为一个一个的<strong>帧</strong>。</p><h2 id="二进制分帧" tabindex="-1"><a class="header-anchor" href="#二进制分帧" aria-hidden="true">#</a> 二进制分帧</h2><p>在不改动 <code>HTTP/1.x</code> 的语义、方法、状态码、URI 以及首部字段……的情况下，<code>HTTP/2</code> 在应用层（<code>HTTP/2</code>）和传输层（<code>TCP</code> or <code>UDP</code>）之间增加一个<strong>二进制分帧层</strong>。</p><figure><img src="'+t+'" alt="image-20220527181454485" tabindex="0" loading="lazy"><figcaption>image-20220527181454485</figcaption></figure><p>在二进制分帧层中，<code>HTTP/2</code> 会将所有传输的信息分割为更小的消息和帧（<code>frame</code>），并对它们采用二进制格式的编码，其中 <code>HTTP1.x</code> 的首部信息会被封装到 <code>HEADER frame</code>，而相应的 <code>Request Body</code> 则封装到 <code>DATA frame</code> 里面。</p><p><code>HTTP/2</code> 通过让所有数据流共用同一个连接，可以更有效地使用 <code>TCP</code> 连接，让高带宽也能真正的服务于 <code>HTTP</code> 的性能提升。</p><p>总结：</p><ul><li><strong>单连接多资源</strong>的方式，减少服务端的链接压力，内存占用更少，连接吞吐量更大</li><li>由于 <code>TCP</code> 连接的减少而使网络拥塞状况得以改善，同时慢启动时间的减少，事拥塞和丢包恢复速度更快</li></ul><h2 id="首部压缩" tabindex="-1"><a class="header-anchor" href="#首部压缩" aria-hidden="true">#</a> 首部压缩</h2><p><code>HTTP/1.1</code>并不支持 <code>HTTP</code> 首部压缩，为此 <code>SPDY</code> 和 <code>HTTP/2</code> 应运而生。<code>HTTP/2</code> 使用了专门为首部压缩而设计的 <strong><code>HPACK</code></strong> <strong>算法</strong>。</p><figure><img src="'+r+'" alt="image-20220527181554326" tabindex="0" loading="lazy"><figcaption>image-20220527181554326</figcaption></figure><h2 id="服务端推送" tabindex="-1"><a class="header-anchor" href="#服务端推送" aria-hidden="true">#</a> 服务端推送</h2><p>服务端推送是一种在客户端请求之前发送数据的机制。在 <code>HTTP/2</code> 中，服务器可以对客户端的<strong>一个</strong>请求发送<strong>多个</strong>响应。如果一个请求是由你的主页发起的，服务器很可能会响应主页内容、logo 以及样式表，因为它知道客户端会用到这些东西。</p><p>服务端推送还有一个很大的优势：可以缓存！也让在遵循同源的情况下，不同页面之间可以共享缓存资源成为可能。</p>',22),s=[n];function g(T,p){return o(),c("div",null,s)}const l=e(i,[["render",g],["__file","http2.0.html.vue"]]);export{l as default};
