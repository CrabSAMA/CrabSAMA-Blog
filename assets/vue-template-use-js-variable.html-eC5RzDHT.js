import{_ as g,c as I,a as c,h as t,i as l,j as o,r as a,o as n}from"./app-B0UMYhNd.js";const i={};function u(C,e){const d=a("Playground");return n(),I("div",null,[e[0]||(e[0]=c("h1",{id:"vue-模版使用常量的渲染问题",tabindex:"-1"},[c("a",{class:"header-anchor",href:"#vue-模版使用常量的渲染问题"},[c("span",null,"Vue 模版使用常量的渲染问题")])],-1)),e[1]||(e[1]=c("h2",{id:"setup-语法糖",tabindex:"-1"},[c("a",{class:"header-anchor",href:"#setup-语法糖"},[c("span",null,"Setup 语法糖")])],-1)),t(d,{title:"Setup%20%E8%AF%AD%E6%B3%95%E7%B3%96",link:"https%3A%2F%2Fsfc.vuejs.org%2F%23__DEV__eyJBcHAudnVlIjoiPHRlbXBsYXRlPlxuICA8YnV0dG9uIEBjbGljaz1cImNoYW5nZVRleHRcIj5jb25zdCArMTwvYnV0dG9uPlxuICA8YnV0dG9uIEBjbGljaz1cImNoYW5nZVwiPnJlZiB1cGRhdGU8L2J1dHRvbj5cbiAgPGJ1dHRvbiBAY2xpY2s9XCJiYXRjaENoYW5nZVwiPmJhdGNoIHVwZGF0ZTwvYnV0dG9uPlxuICA8ZGl2IGtleT1cIjFcIj57eyB0ZXh0IH19PC9kaXY%2BXG4gIDxkaXY%2Be3sgZmxhZyB9fTwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdCBzZXR1cCBsYW5nPVwidHNcIj5cbmltcG9ydCB7IHJlZiB9IGZyb20gJ3Z1ZSdcbmNvbnN0IGZsYWcgPSByZWYoZmFsc2UpXG5sZXQgdGV4dCA9IDFcblxuY29uc3QgY2hhbmdlID0gKCkgPT4ge1xuICBmbGFnLnZhbHVlID0gIWZsYWcudmFsdWVcbn1cblxuY29uc3QgY2hhbmdlVGV4dCA9ICgpID0%2BIHtcbiAgdGV4dCsrXG59XG5cbmNvbnN0IGJhdGNoQ2hhbmdlID0gKCkgPT4ge1xuICBjaGFuZ2UoKVxuICBjaGFuZ2VUZXh0KClcbn1cbjwvc2NyaXB0PlxuIn0%3D"}),e[2]||(e[2]=l('<ul><li><code>flag</code> 和 <code>text</code> 都能在模版上渲染出来</li><li>执行 <code>changeText</code> 方法，<code>text</code> 的值会更新，但不渲染</li><li>执行 <code>change</code> 方法，<code>flag</code> 的值会更新并渲染</li><li>先执行 <code>changeText</code> 方法，再执行 <code>change</code> 方法，<code>flag</code> 和 <code>text</code> 的值都会更新并渲染</li><li>执行 <code>batchChange</code> 方法，<code>flag</code> 和 <code>text</code> 的值都会更新并渲染</li></ul><h3 id="分析" tabindex="-1"><a class="header-anchor" href="#分析"><span>分析</span></a></h3><p>通过 Vue SFC Playground 查看 Vue SFC 编译后的代码，可以看到 <code>text</code> 和 <code>flag</code> 用于渲染显示的值是从 <code>$setup</code> 这个对象上面取的，因此我们可以推断，在使用 setup 语法糖的时候，所有在 setup script 块里面的变量都会被导出并绑定在 <code>$setup</code> 这个对象上。同时我们还看到我们定义的 js 变量被进行了处理，使用 get / set 修饰符进行了包裹。</p><p>直接更新 ref 时值和模版都能被正常渲染，这个是毋庸置疑的，我们需要去思考的是 js 变量的现象。可以看到，在单独更新 js 变量时，值能被更新但不会渲染，而当再次触发 ref 更新的时候，会顺带将 js 变量当前的值渲染出来，证明了值是有在正常更新的，只不过由于是普通的变量，因此它的变更不会被响应式收集副作用，但在 Vue 重新渲染的时候，就会正常地被渲染出来。</p><h2 id="option-api-setup-写法" tabindex="-1"><a class="header-anchor" href="#option-api-setup-写法"><span>Option API + setup 写法</span></a></h2>',5)),t(d,{title:"Option%20API%20%2B%20setup%20%E5%86%99%E6%B3%95",link:"https%3A%2F%2Fsfc.vuejs.org%2F%23__DEV__eyJBcHAudnVlIjoiPHRlbXBsYXRlPlxuICA8YnV0dG9uIEBjbGljaz1cImNoYW5nZVRleHRcIj5jb25zdCArMTwvYnV0dG9uPlxuICA8YnV0dG9uIEBjbGljaz1cImNoYW5nZVwiPnJlZiB1cGRhdGU8L2J1dHRvbj5cbiAgPGJ1dHRvbiBAY2xpY2s9XCJiYXRjaENoYW5nZVwiPmJhdGNoIHVwZGF0ZTwvYnV0dG9uPlxuICA8ZGl2IGtleT1cIjFcIj57eyB0ZXh0IH19PC9kaXY%2BXG4gIDxkaXY%2Be3sgZmxhZyB9fTwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdCBsYW5nPVwidHNcIj5cbmltcG9ydCB7IHJlZiwgZGVmaW5lQ29tcG9uZW50IH0gZnJvbSAndnVlJ1xuZXhwb3J0IGRlZmF1bHQgZGVmaW5lQ29tcG9uZW50KHtcbiAgc2V0dXAoKSB7XG4gICAgY29uc3QgZmxhZyA9IHJlZihmYWxzZSlcbiAgICBsZXQgdGV4dCA9IDFcblxuICAgIGNvbnN0IGNoYW5nZSA9ICgpID0%2BIHtcbiAgICAgIGZsYWcudmFsdWUgPSAhZmxhZy52YWx1ZVxuICAgIH1cblxuICAgIGNvbnN0IGNoYW5nZVRleHQgPSAoKSA9PiB7XG4gICAgICB0ZXh0KytcbiAgICB9XG5cbiAgICBjb25zdCBiYXRjaENoYW5nZSA9ICgpID0%2BIHtcbiAgICAgIGNoYW5nZSgpXG4gICAgICBjaGFuZ2VUZXh0KClcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZsYWcsXG4gICAgICB0ZXh0LFxuICAgICAgY2hhbmdlLFxuICAgICAgY2hhbmdlVGV4dCxcbiAgICAgIGJhdGNoQ2hhbmdlLFxuICAgIH1cbiAgfSxcbn0pXG48L3NjcmlwdD5cbiJ9"}),e[3]||(e[3]=l('<ul><li><code>flag</code> 和 <code>text</code> 都能在模版上渲染出来</li><li>执行 <code>changeText</code> 方法，<code>text</code> 的值会更新，但不会渲染</li><li>执行 <code>change</code> 方法，<code>flag</code> 的值会更新并渲染</li><li>先执行 <code>changeText</code> 方法，再执行 <code>change</code> 方法，<code>text</code> 和 <code>flag</code> 的值都会更新，但只有 <code>flag</code> 的值渲染</li><li>执行 <code>batchChange</code> 方法，<code>text</code> 和 <code>flag</code> 的值都会更新，但只有 <code>flag</code> 的值渲染</li></ul><h3 id="分析-1" tabindex="-1"><a class="header-anchor" href="#分析-1"><span>分析</span></a></h3><p>查看 Vue SFC 编译后的代码，可以发现在使用 Option API + setup 写法的时候，针对变量展示时的取值不一样了，这个时候是从 <code>_ctx</code> 这个对象上面取的。<code>_ctx</code> 这个对象我们在研究后发现，这个就是我们使用 Option API 时常用的 <code>this</code>。当使用 Option API + setup 写法时，setup 函数中导出的变量会被绑定到 <code>_ctx</code> 下，也就是 <code>this</code> 下。</p><p>那为什么在使用这种写法的时候，值有更新，但是不会被渲染呢？第一时间我想到的是，setup 导出的值绑定到 <code>_ctx</code> 的这个过程用的是引用传参。这种传参方式在对待普通变量时，就等于直接将字面值进行赋值，而对待复杂变量（例如对象、数组等）时，是将它的地址进行赋值。要验证这个猜想也很简单，我们只需要将 <code>text</code> 这个普通变量改为对象，然后尝试更改它里面的属性看看是否符合预期即可。</p><p>测试代码如下：</p>',5)),t(d,{title:"Option%20API%20%2B%20setup%20%E5%86%99%E6%B3%95%EF%BC%8C%E9%AA%8C%E8%AF%81%E5%A4%8D%E6%9D%82%E5%8F%98%E9%87%8F",link:"https%3A%2F%2Fsfc.vuejs.org%2F%23__DEV__eyJBcHAudnVlIjoiPHRlbXBsYXRlPlxuICA8YnV0dG9uIEBjbGljaz1cImNoYW5nZVRleHRcIj5jb25zdCArMTwvYnV0dG9uPlxuICA8YnV0dG9uIEBjbGljaz1cImNoYW5nZVwiPnJlZiB1cGRhdGU8L2J1dHRvbj5cbiAgPGJ1dHRvbiBAY2xpY2s9XCJiYXRjaENoYW5nZVwiPmJhdGNoIHVwZGF0ZTwvYnV0dG9uPlxuICA8ZGl2IGtleT1cIjFcIj57eyBvYmoudGV4dCB9fTwvZGl2PlxuICA8ZGl2Pnt7IGZsYWcgfX08L2Rpdj5cbjwvdGVtcGxhdGU%2BXG5cbjxzY3JpcHQgbGFuZz1cInRzXCI%2BXG5pbXBvcnQgeyByZWYsIGRlZmluZUNvbXBvbmVudCB9IGZyb20gJ3Z1ZSdcbmV4cG9ydCBkZWZhdWx0IGRlZmluZUNvbXBvbmVudCh7XG4gIHNldHVwKCkge1xuICAgIGNvbnN0IGZsYWcgPSByZWYoZmFsc2UpXG4gICAgbGV0IG9iaiA9IHsgdGV4dDogMSB9XG5cbiAgICBjb25zdCBjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICBmbGFnLnZhbHVlID0gIWZsYWcudmFsdWVcbiAgICB9XG5cbiAgICBjb25zdCBjaGFuZ2VUZXh0ID0gKCkgPT4ge1xuICAgICAgb2JqLnRleHQrK1xuICAgIH1cblxuICAgIGNvbnN0IGJhdGNoQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgY2hhbmdlKClcbiAgICAgIGNoYW5nZVRleHQoKVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZmxhZyxcbiAgICAgIG9iaixcbiAgICAgIGNoYW5nZSxcbiAgICAgIGNoYW5nZVRleHQsXG4gICAgICBiYXRjaENoYW5nZSxcbiAgICB9XG4gIH0sXG59KVxuPC9zY3JpcHQ%2BXG4ifQ%3D%3D"}),e[4]||(e[4]=c("p",null,[o("这段代码的执行情况正如我们所想的那样，与上面 setup 语法糖的执行效果一致："),c("code",null,"obj.text"),o(" 的值有在更新，但不会被响应式收集，需要借助 ref 值变更时的副作用进行渲染。到这里我们基本可以定论："),c("strong",null,[o("setup 导出的值绑定到 "),c("code",null,"_ctx"),o(" 的这个过程用的就是引用传参")]),o("。")],-1)),e[5]||(e[5]=c("p",null,"借助这段代码更好理解：",-1)),t(d,{title:"Option%20API%20%2B%20setup%20%E5%86%99%E6%B3%95%EF%BC%8C%E9%AA%8C%E8%AF%81%E5%80%BC%E7%9A%84%E7%BB%91%E5%AE%9A%E6%8C%87%E5%90%91",link:"https%3A%2F%2Fsfc.vuejs.org%2F%23__DEV__eyJBcHAudnVlIjoiPHRlbXBsYXRlPlxuICA8YnV0dG9uIEBjbGljaz1cImNoYW5nZVRleHRcIj5jb25zdCArMTwvYnV0dG9uPlxuICA8YnV0dG9uIEBjbGljaz1cImNoYW5nZVwiPnJlZiB1cGRhdGU8L2J1dHRvbj5cbiAgPGJ1dHRvbiBAY2xpY2s9XCJiYXRjaENoYW5nZVwiPmJhdGNoIHVwZGF0ZTwvYnV0dG9uPlxuICA8YnV0dG9uIEBjbGljaz1cInNob3dcIj5zaG93PC9idXR0b24%2BXG4gIDxkaXYga2V5PVwiMVwiPnt7IHRleHQgfX08L2Rpdj5cbiAgPGRpdj57eyBmbGFnIH19PC9kaXY%2BXG48L3RlbXBsYXRlPlxuXG48c2NyaXB0IGxhbmc9XCJ0c1wiPlxuaW1wb3J0IHsgcmVmLCBkZWZpbmVDb21wb25lbnQgfSBmcm9tICd2dWUnXG5leHBvcnQgZGVmYXVsdCBkZWZpbmVDb21wb25lbnQoe1xuICBtZXRob2RzOiB7XG4gICAgc2hvdygpIHtcbiAgICAgIGFsZXJ0KHRoaXMudGV4dClcbiAgICB9LFxuICB9LFxuICBzZXR1cCgpIHtcbiAgICBjb25zdCBmbGFnID0gcmVmKGZhbHNlKVxuICAgIGxldCB0ZXh0ID0gMVxuXG4gICAgY29uc3QgY2hhbmdlID0gKCkgPT4ge1xuICAgICAgZmxhZy52YWx1ZSA9ICFmbGFnLnZhbHVlXG4gICAgfVxuXG4gICAgY29uc3QgY2hhbmdlVGV4dCA9ICgpID0%2BIHtcbiAgICAgIHRleHQrK1xuICAgICAgYWxlcnQodGV4dClcbiAgICB9XG5cbiAgICBjb25zdCBiYXRjaENoYW5nZSA9ICgpID0%2BIHtcbiAgICAgIGNoYW5nZSgpXG4gICAgICBjaGFuZ2VUZXh0KClcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZsYWcsXG4gICAgICB0ZXh0LFxuICAgICAgY2hhbmdlLFxuICAgICAgY2hhbmdlVGV4dCxcbiAgICAgIGJhdGNoQ2hhbmdlLFxuICAgIH1cbiAgfSxcbn0pXG48L3NjcmlwdD5cbiJ9"}),e[6]||(e[6]=l('<p>可以发现，<code>changeText</code> 这里面的 <code>text</code> 确实有在变更，但其实这个 <code>text</code> 和绑定到 <code>_ctx</code> 上面的 <code>text</code> 已经不是一个东西了，触发 <code>show</code> 方法可以看到 <code>this.text</code> 一直没有变更。我们执行 <code>changeText</code> 的时候是通过闭包的特性引用了在 setup 函数中定义的 <code>text</code> 变量，修改的是这个闭包变量值。</p><h3 id="为什么-setup-语法糖下变量能被正常更新" tabindex="-1"><a class="header-anchor" href="#为什么-setup-语法糖下变量能被正常更新"><span>为什么 setup 语法糖下变量能被正常更新？</span></a></h3><p>在使用 setup 语法糖时，编译器会对常量进行包裹，同时生成一个新的闭包 <code>$setup</code>。因此在执行代码的过程中，变更的一直是 <code>$setup</code> 里面的值，同时模版中也是直接取 <code>$setup</code> 中的同一个值，因此变量能正常更新。</p><h2 id="option-api-写法" tabindex="-1"><a class="header-anchor" href="#option-api-写法"><span>Option API 写法</span></a></h2>',4)),t(d,{title:"Option%20API%20%E5%86%99%E6%B3%95",link:"https%3A%2F%2Fsfc.vuejs.org%2F%23__DEV__eyJBcHAudnVlIjoiPHRlbXBsYXRlPlxuICA8YnV0dG9uIEBjbGljaz1cImNoYW5nZVRleHRcIj5jb25zdCArMTwvYnV0dG9uPlxuICA8YnV0dG9uIEBjbGljaz1cImNoYW5nZVwiPnJlZiB1cGRhdGU8L2J1dHRvbj5cbiAgPGJ1dHRvbiBAY2xpY2s9XCJiYXRjaENoYW5nZVwiPmJhdGNoIHVwZGF0ZTwvYnV0dG9uPlxuICA8ZGl2IGtleT1cIjFcIj57eyB0ZXh0IH19PC9kaXY%2BXG4gIDxkaXY%2Be3sgZmxhZyB9fTwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdCBsYW5nPVwidHNcIj5cbmltcG9ydCB7IGRlZmluZUNvbXBvbmVudCB9IGZyb20gJ3Z1ZSdcbmxldCB0ZXh0ID0gMVxuZXhwb3J0IGRlZmF1bHQgZGVmaW5lQ29tcG9uZW50KHtcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmxhZzogZmFsc2UsXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgY2hhbmdlKCkge1xuICAgICAgdGhpcy5mbGFnID0gIXRoaXMuZmxhZ1xuICAgIH0sXG4gICAgY2hhbmdlVGV4dCgpIHtcbiAgICAgIHRleHQrK1xuICAgIH0sXG4gICAgYmF0Y2hDaGFuZ2UoKSB7XG4gICAgICB0aGlzLmNoYW5nZSgpXG4gICAgICB0aGlzLmNoYW5nZVRleHQoKVxuICAgIH0sXG4gIH0sXG59KVxuPC9zY3JpcHQ%2BXG4ifQ%3D%3D"}),e[7]||(e[7]=l('<ul><li><code>flag</code> 能在模版上渲染出来，<code>text</code> 无法在模版上渲染出来</li><li>执行 <code>change</code> 方法，<code>flag</code> 的值会更新</li><li>执行 <code>batchChange</code> 方法，<code>flag</code> 和 <code>text</code> 的值都会更新</li></ul><h3 id="分析-2" tabindex="-1"><a class="header-anchor" href="#分析-2"><span>分析</span></a></h3><p>最后一种情况，单纯使用 Option API 的写法，其实在编译过程中编译器已经会提示我们：</p><div class="hint-container warning"><p class="hint-container-title">Warning</p><blockquote><p>Property &quot;text&quot; was accessed during render but is not defined on instance.<br> at &lt;Repl&gt;</p></blockquote></div><p>在看完上面的分析后，我们很容易就知道是什么原因：<code>text</code> 这个变量并没有被绑定到 <code>_ctx</code> 下。那自然是没有办法在模版中使用。</p><p>这种写法与上面的第二种情况类似，此处就不做过多赘述。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><p>在对 Vue 模版中使用常量的渲染问题进行分析后，我们发现 setup 语法糖并不是简单的语法变化，它里面还存在一些隐藏的逻辑，比如上面提到的对常量的包裹。同时我们也会发现，使用 setup 语法糖时的一些行为是和使用 setup 函数不一样的。因此我们在后续的使用过程中，要尽量避免踩到这两者差异导致的坑。</p><p>同时我们需要了解的是，在 Vue 模版中使用 js 常量并不是好的习惯，我们需要在模版中实现响应式更新的效果，就需要将对应的值处理成 ref，这个才是避免问题出现的根本解决方案。但有些时候我们会有这种需求，那此时我们就需要结合这篇文章里面提到的知识点，尽量避免踩坑。</p>',9))])}const b=g(i,[["render",u]]),G=JSON.parse('{"path":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vue-template-use-js-variable.html","title":"Vue 模版使用常量的渲染问题","lang":"zh-CN","frontmatter":{"title":"Vue 模版使用常量的渲染问题","date":"2024-08-22T07:53:11.000Z","category":["学习笔记"],"tag":["Vue"],"description":"Vue 模版使用常量的渲染问题 Setup 语法糖 flag 和 text 都能在模版上渲染出来 执行 changeText 方法，text 的值会更新，但不渲染 执行 change 方法，flag 的值会更新并渲染 先执行 changeText 方法，再执行 change 方法，flag 和 text 的值都会更新并渲染 执行 batchChange...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue 模版使用常量的渲染问题\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2024-08-22T07:53:11.000Z\\",\\"dateModified\\":\\"2024-08-22T08:29:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CrabSAMA\\",\\"url\\":\\"https://crabsama.github.io/CrabSAMA-Blog\\"}]}"],["meta",{"property":"og:url","content":"https://crabsama.github.io/CrabSAMA-Blog/CrabSAMA-Blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/vue-template-use-js-variable.html"}],["meta",{"property":"og:site_name","content":"CrabSAMA · 笔记"}],["meta",{"property":"og:title","content":"Vue 模版使用常量的渲染问题"}],["meta",{"property":"og:description","content":"Vue 模版使用常量的渲染问题 Setup 语法糖 flag 和 text 都能在模版上渲染出来 执行 changeText 方法，text 的值会更新，但不渲染 执行 change 方法，flag 的值会更新并渲染 先执行 changeText 方法，再执行 change 方法，flag 和 text 的值都会更新并渲染 执行 batchChange..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-22T08:29:16.000Z"}],["meta",{"property":"article:tag","content":"Vue"}],["meta",{"property":"article:published_time","content":"2024-08-22T07:53:11.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-22T08:29:16.000Z"}]]},"git":{"createdTime":1724313559000,"updatedTime":1724315356000,"contributors":[{"name":"CrabSAMA","username":"CrabSAMA","email":"71915282@qq.com","commits":2,"url":"https://github.com/CrabSAMA"}]},"readingTime":{"minutes":6.3,"words":1890},"filePathRelative":"学习笔记/vue-template-use-js-variable.md","excerpt":"\\n<h2>Setup 语法糖</h2>\\n\\n<ul>\\n<li><code>flag</code> 和 <code>text</code> 都能在模版上渲染出来</li>\\n<li>执行 <code>changeText</code> 方法，<code>text</code> 的值会更新，但不渲染</li>\\n<li>执行 <code>change</code> 方法，<code>flag</code> 的值会更新并渲染</li>\\n<li>先执行 <code>changeText</code> 方法，再执行 <code>change</code> 方法，<code>flag</code> 和 <code>text</code> 的值都会更新并渲染</li>\\n<li>执行 <code>batchChange</code> 方法，<code>flag</code> 和 <code>text</code> 的值都会更新并渲染</li>\\n</ul>","autoDesc":true}');export{b as comp,G as data};
