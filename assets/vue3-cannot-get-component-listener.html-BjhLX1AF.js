import{_ as o,c as t,i as r,o as c}from"./app-DOF6gB1w.js";const p={};function n(a,e){return c(),t("div",null,e[0]||(e[0]=[r('<h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h2><p>在 Vue 3 中，有一个需求，想要通过判断用户是否传入事件处理函数，如果传入事件处理函数证明点击事件需要被处理，来决定是否给元素添加 pointer 的样式，因此我们需要有一种方式能访问到传入的事件处理函数。</p><h2 id="思路" tabindex="-1"><a class="header-anchor" href="#思路"><span>思路</span></a></h2><p>在看 Vue 源码的时候我们知道其实本质上事件处理函数也是挂载在 <code>props</code> 上的，因此我尝试直接通过 <code>$props</code> 去获取，结果发现并无法获取，结合之前看的源码，<code>props</code> 本质上也是一个 Proxy，在这个 Proxy <code>get</code> 的时候会去判断这个属性是否显式地在 <code>props</code> 上定义，如果是的话才会返回，否则就不返回，直观的表现就是无法访问到这个属性。很明显我们是通过 <code>defineEmits</code> 去定义的事件，因此 <code>props</code> 这个 Proxy <code>get</code> 的时候并不会将事件处理函数返回。</p><p>在 Vue 2 中我们可以通过 <code>$listener</code> 去访问到这个事件处理函数</p><blockquote><h3 id="vm-listeners" tabindex="-1"><a class="header-anchor" href="#vm-listeners"><span><a href="https://v2.cn.vuejs.org/v2/api/#vm-listeners" target="_blank" rel="noopener noreferrer">vm.$listeners</a></span></a></h3><blockquote><p>2.4.0 新增</p></blockquote><ul><li><p><strong>类型</strong>：<code>{ [key: string]: Function | Array&lt;Function&gt; }</code></p></li><li><p><strong>只读</strong></p></li><li><p><strong>详细</strong>：</p><p>包含了父作用域中的 (不含 <code>.native</code> 修饰器的) <code>v-on</code> 事件监听器。它可以通过 <code>v-on=&quot;$listeners&quot;</code> 传入内部组件——在创建更高层次的组件时非常有用。</p></li></ul></blockquote><p>但目前看在 Vue 3 中我们没有途径去获取到组件传入的事件处理函数，看官方的 rfc 讨论似乎也没有结果。</p><p><a href="https://github.com/vuejs/rfcs/discussions/397" target="_blank" rel="noopener noreferrer">https://github.com/vuejs/rfcs/discussions/397</a></p><p>Vue 源码关于 props Proxy 取值相关的代码：</p><p><a href="https://github.com/vuejs/core/blob/cdffaf6b9efce2c52635714e8e2d7480737c6b50/packages/runtime-core/src/compat/props.ts#L25-L28" target="_blank" rel="noopener noreferrer">https://github.com/vuejs/core/blob/cdffaf6b9efce2c52635714e8e2d7480737c6b50/packages/runtime-core/src/compat/props.ts#L25-L28</a></p><h2 id="解决方法" tabindex="-1"><a class="header-anchor" href="#解决方法"><span>解决方法</span></a></h2><p>目前暂时的解法是在 <code>props</code> 中显式地去定义一个 <code>onXXX</code> 的 prop，这不会影响 emit 定义的事件，也不会影响子组件中使用 <code>@xxx</code> 去绑定事件处理函数，我们要通过这种 hack 的方式去让 Vue 能在 <code>$props</code> 中返回对应的事件处理函数。</p>',12)]))}const d=o(p,[["render",n]]),i=JSON.parse('{"path":"/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/vue3-cannot-get-component-listener.html","title":"Vue3 中无法获取组件的事件监听函数","lang":"zh-CN","frontmatter":{"title":"Vue3 中无法获取组件的事件监听函数","date":"2025-06-06T12:43:32.000Z","category":["解决方案"],"tag":["Vue"],"description":"背景 在 Vue 3 中，有一个需求，想要通过判断用户是否传入事件处理函数，如果传入事件处理函数证明点击事件需要被处理，来决定是否给元素添加 pointer 的样式，因此我们需要有一种方式能访问到传入的事件处理函数。 思路 在看 Vue 源码的时候我们知道其实本质上事件处理函数也是挂载在 props 上的，因此我尝试直接通过 $props 去获取，结果...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Vue3 中无法获取组件的事件监听函数\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-06-06T12:43:32.000Z\\",\\"dateModified\\":\\"2025-06-06T12:44:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CrabSAMA\\",\\"url\\":\\"https://crabsama.github.io/CrabSAMA-Blog\\"}]}"],["meta",{"property":"og:url","content":"https://crabsama.github.io/CrabSAMA-Blog/CrabSAMA-Blog/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/vue3-cannot-get-component-listener.html"}],["meta",{"property":"og:site_name","content":"CrabSAMA · 笔记"}],["meta",{"property":"og:title","content":"Vue3 中无法获取组件的事件监听函数"}],["meta",{"property":"og:description","content":"背景 在 Vue 3 中，有一个需求，想要通过判断用户是否传入事件处理函数，如果传入事件处理函数证明点击事件需要被处理，来决定是否给元素添加 pointer 的样式，因此我们需要有一种方式能访问到传入的事件处理函数。 思路 在看 Vue 源码的时候我们知道其实本质上事件处理函数也是挂载在 props 上的，因此我尝试直接通过 $props 去获取，结果..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-06-06T12:44:30.000Z"}],["meta",{"property":"article:tag","content":"Vue"}],["meta",{"property":"article:published_time","content":"2025-06-06T12:43:32.000Z"}],["meta",{"property":"article:modified_time","content":"2025-06-06T12:44:30.000Z"}]]},"git":{"createdTime":1749213870000,"updatedTime":1749213870000,"contributors":[{"name":"CrabSAMA","username":"CrabSAMA","email":"71915282@qq.com","commits":1,"url":"https://github.com/CrabSAMA"}]},"readingTime":{"minutes":1.77,"words":532},"filePathRelative":"解决方案/vue3-cannot-get-component-listener.md","excerpt":"<h2>背景</h2>\\n<p>在 Vue 3 中，有一个需求，想要通过判断用户是否传入事件处理函数，如果传入事件处理函数证明点击事件需要被处理，来决定是否给元素添加 pointer 的样式，因此我们需要有一种方式能访问到传入的事件处理函数。</p>\\n<h2>思路</h2>\\n<p>在看 Vue 源码的时候我们知道其实本质上事件处理函数也是挂载在 <code>props</code> 上的，因此我尝试直接通过 <code>$props</code> 去获取，结果发现并无法获取，结合之前看的源码，<code>props</code> 本质上也是一个 Proxy，在这个 Proxy <code>get</code> 的时候会去判断这个属性是否显式地在 <code>props</code> 上定义，如果是的话才会返回，否则就不返回，直观的表现就是无法访问到这个属性。很明显我们是通过 <code>defineEmits</code> 去定义的事件，因此 <code>props</code> 这个 Proxy <code>get</code> 的时候并不会将事件处理函数返回。</p>","autoDesc":true}');export{d as comp,i as data};
