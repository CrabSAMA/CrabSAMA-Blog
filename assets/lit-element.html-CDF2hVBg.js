import{_ as i,c as e,i as a,o as t}from"./app-BN3TCIWe.js";const n={};function l(h,s){return t(),e("div",null,s[0]||(s[0]=[a(`<h1 id="lit-element" tabindex="-1"><a class="header-anchor" href="#lit-element"><span>Lit Element</span></a></h1><h2 id="vue-中使用-web-componment-传参" tabindex="-1"><a class="header-anchor" href="#vue-中使用-web-componment-传参"><span>Vue 中使用 Web Componment 传参</span></a></h2><blockquote><p><a href="https://cn.vuejs.org/guide/extras/web-components.html#using-custom-elements-in-vue" target="_blank" rel="noopener noreferrer">在 Vue 中使用自定义元素</a></p></blockquote><p>针对基础非响应变量，一般可以直接通过 v-bind 方式传入；但如果是复杂数据类型或者响应变量，直接传入会导致响应式更新失效、数据传入失败等问题。建议始终使用 <code>.prop</code> 修饰符来进行传参，保证数据可以正确传入到组件中。</p><div class="language-vue line-numbers-mode" data-highlighter="shiki" data-ext="vue" data-title="vue" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">my-element</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> :</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">user</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">prop</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{ </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">name</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;jack&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">my-element</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">&lt;!-- 等价简写 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">my-element</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> .</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">user</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{ </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">name</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;jack&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> }</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;&lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">my-element</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="property-和-state-的区别" tabindex="-1"><a class="header-anchor" href="#property-和-state-的区别"><span>@property 和 @state 的区别</span></a></h2><p><code>@property</code> 用于标识这个属性是支持外部传入的，使用 <code>@property</code> 修饰的变量在接受到传参时会进行处理，因此需要在 <code>@property</code> 修饰器中定义正确的数据类型。同时在 <code>lit</code> 中使用时，<code>@property</code> 修饰的变量需要使用 <code>.foo = \${this.foo}</code> 的方式传入。</p><p><code>@state</code> 定义的同样是响应式变量，即变更时会自动触发 DOM 更新的变量，但 <code>@state</code> 修饰符修饰的变量是一个类中的内部变量，可以类比 Vue 中的 data 数据。</p><p>两个修饰符修饰的变量都是响应式变量。</p><h2 id="watch-变量变更" tabindex="-1"><a class="header-anchor" href="#watch-变量变更"><span>watch 变量变更</span></a></h2><p>重写类下的 <code>updated</code> 方法，<code>updated</code> 方法的第一个参数是一个 map，记录着变更的值，key 为变更的变量名，value 为变更前的值，因此如果要实现类似 Vue 中的 watch 功能，可以这样写：</p><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">protected</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> override</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> updated</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  _changedProperties</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">PropertyValueMap</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">any</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">&gt;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> |</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> Map</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">PropertyKey</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">unknown</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">): </span><span style="--shiki-light:#0184BC;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">_changedProperties</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">has</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;data&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 旧数据</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> oldData</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> _changedProperties</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;data&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 变更后的数据</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#986801;--shiki-dark:#E5C07B;"> newData</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">data</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期"><span>生命周期</span></a></h2><blockquote><p>面向 React 开发者的 Lit</p><p><a href="https://codelabs.developers.google.com/codelabs/lit-2-for-react-devs?hl=zh-cn#5" target="_blank" rel="noopener noreferrer">状态与生命周期</a></p></blockquote><table><thead><tr><th>Lit</th><th>Vue</th><th>React</th><th>描述</th></tr></thead><tbody><tr><td><code>constructor</code></td><td><code>setup</code> / <code>created</code></td><td><code>constructor</code></td><td>类组件中 <code>constructor</code> 是最初调用的方法，如果是 functional component 中，则就是 <code>setup</code></td></tr><tr><td><code>firstUpdated</code></td><td><code>beforeMount</code></td><td><code>componentDidMount</code></td><td>首次将组件的模板渲染到组件的根节点中时调用</td></tr><tr><td><code>connectedCallback</code></td><td><code>mounted</code></td><td><code>componentDidMount</code></td><td>每当将元素插入 DOM 树中时调用</td></tr><tr><td><code>updated</code></td><td><code>updated</code></td><td><code>componentDidUpdate</code></td><td>数据更新时调用</td></tr><tr><td><code>disconnectedCallback</code></td><td><code>unmounted</code></td><td><code>componentWillUnmount</code></td><td>与 <code>componentWillUnmount</code> 不同，<code>disconnectedCallback</code> 在元素从树中移除<strong>之后</strong>调用</td></tr></tbody></table><h2 id="lit-中使用-unocss" tabindex="-1"><a class="header-anchor" href="#lit-中使用-unocss"><span>lit 中使用 unocss</span></a></h2><p><code>unocss</code>是一个原子类框架。在 lit 中使用时，由于 <code>web component</code> 的 <code>shadow dom</code> 将样式都隔离开了，因此在需要生成样式的地方要配置一个占位符，<code>unocss</code> 引擎才知道需要将 css 生成在何处。比如我们可以这样写：</p><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" data-title="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyElement</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LitElement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  render</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> html</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">\`</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      &lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">style</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        @unocss-placeholed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">      &lt;/</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">style</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    \`</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">  static</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> styles</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> css</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">\`</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    @unocss-placeholed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  \`</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两种写法都是可以被识别的，在实际使用中按需使用即可。</p><h2 id="ref-引用" tabindex="-1"><a class="header-anchor" href="#ref-引用"><span>Ref 引用</span></a></h2><p>在开发时我们会有获取到 DOM 元素对象的需求，在 lit 中可以使用 <code>@query</code> 修饰器来获取。</p><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" data-title="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">query</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;#seamless-scroll-wrap&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">wrapRef</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">HTMLElement</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// get offsetWidth</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">slotListRef</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">offsetWidth</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想要获取 slot 下面的 DOM 元素对象，lit 也提供了 <code>@queryAssignedElements</code> 修饰器。通过这个修饰器获取回来的是一个数组，里面存着 slot 下面的所有 DOM 节点。</p><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" data-title="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">queryAssignedElements</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">slotItemList</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">Array</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">HTMLElement</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// get outerHTML and join it</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">slotItemList</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">map</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">((</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">slot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> slot</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">outerHTML</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">).</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">join</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="直接渲染-html-字符串" tabindex="-1"><a class="header-anchor" href="#直接渲染-html-字符串"><span>直接渲染 html 字符串</span></a></h2><p>类似 Vue 中的 v-html，lit 提供了 <code>unsafeHTML</code> 方法来渲染 html 字符串，但与 Vue 一样的是，我们需要保证 html 字符串的安全性，防止被 XSS 攻击。</p><h2 id="computed-计算属性" tabindex="-1"><a class="header-anchor" href="#computed-计算属性"><span>Computed 计算属性</span></a></h2><p>在 Vue 中我们经常会使用 <code>computed</code> 来实现一些数据需求，在 lit 中由于一个组件就是一个类，而 ES5 类中提供了 <code>get</code>/<code>set</code> 方法，可以实现到一个值的 getter/setter，因此直接在类中写属性值的 get 方法即可实现类似 <code>computed</code> 的效果。</p><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" data-title="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> MyElement</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> extends</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> LitElement</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#0184BC;--shiki-dark:#C678DD;">  get</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> canRender</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">requiredProps</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> true</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="样式问题" tabindex="-1"><a class="header-anchor" href="#样式问题"><span>样式问题</span></a></h2><p>在 web component 中，样式其实是遇到问题最多的地方，由于 shadow dom 的存在，使得样式做了隔离，它将组件的内部结构、样式和行为与页面的其他部分隔离开来。</p><p>一般来说，我们在类下的 <code>styles</code> 属性中定义的样式，只会在<strong>当前组件</strong>下生效，在 <code>render</code> 方法里去写一个 <code>style</code> 标签效果是一样的。如果想在组件里更改外部样式，就要用到 <code>:host</code> 和 <code>:root</code> 两个伪类选择器</p><ul><li><code>:host</code> 选择器：当前自定义元素的根元素，仅在组件的 shadow dom 内部生效，不会影响到组件外部的元素</li><li><code>:root</code> 选择器：<code>:root</code> 选择器在整个文档中生效。在 Web Components 的上下文中，它选择到的就是 Shadow DOM 的根元素，但在组件外部，它也可以用于定位整个文档的根元素（如 <code>&lt;html&gt;</code> 标签）</li></ul><p>在 Web Components 中，样式的继承关系可以分为以下几个层次：</p><ol><li>全局样式：在主文档中定义的全局样式，例如使用<code>&lt;style&gt;</code>标签或外部样式表。这些样式会应用到整个页面，但不会直接影响到 Web Components 的 Shadow DOM 内部。</li><li>组件样式：在组件的 Shadow DOM 中定义的样式。这些样式只会应用到组件内部，不会影响到页面的其他部分。组件样式可以通过<code>&lt;style&gt;</code>标签或外部样式表来定义。</li><li>继承样式：在 Web Components 中，某些 CSS 属性是可以继承的，例如字体、颜色等。这意味着，如果在主文档中为一个元素设置了这些属性，它们会被组件内部的相应元素继承。但是，其他非继承属性（如边距、背景等）不会被组件内部的元素继承。</li><li>CSS 自定义属性（CSS Variables）：CSS 自定义属性是一种可以跨越 Shadow DOM 边界的样式。通过在主文档中定义自定义属性，然后在组件内部使用这些属性，可以实现对组件样式的定制。例如，可以在主文档中定义一个自定义颜色属性，然后在组件内部使用这个颜色属性来设置元素的颜色。但需要注意的是，自定义组件内无法修改主文档中的自定义属性，只能在内部定义一个属性将其内部覆盖。</li></ol><h2 id="与-omi-框架对比" tabindex="-1"><a class="header-anchor" href="#与-omi-框架对比"><span>与 omi 框架对比</span></a></h2>`,36)]))}const d=i(n,[["render",l],["__file","lit-element.html.vue"]]),k=JSON.parse('{"path":"/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/lit-element.html","title":"Lit Element","lang":"zh-CN","frontmatter":{"title":"Lit Element","date":"2023-06-14T05:43:58.000Z","category":["学习笔记"],"tag":["Lit"],"description":"Lit Element Vue 中使用 Web Componment 传参 在 Vue 中使用自定义元素 针对基础非响应变量，一般可以直接通过 v-bind 方式传入；但如果是复杂数据类型或者响应变量，直接传入会导致响应式更新失效、数据传入失败等问题。建议始终使用 .prop 修饰符来进行传参，保证数据可以正确传入到组件中。 @property 和 @...","head":[["meta",{"property":"og:url","content":"https://crabsama.github.io/CrabSAMA-Blog/CrabSAMA-Blog/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/lit-element.html"}],["meta",{"property":"og:site_name","content":"CrabSAMA · 笔记"}],["meta",{"property":"og:title","content":"Lit Element"}],["meta",{"property":"og:description","content":"Lit Element Vue 中使用 Web Componment 传参 在 Vue 中使用自定义元素 针对基础非响应变量，一般可以直接通过 v-bind 方式传入；但如果是复杂数据类型或者响应变量，直接传入会导致响应式更新失效、数据传入失败等问题。建议始终使用 .prop 修饰符来进行传参，保证数据可以正确传入到组件中。 @property 和 @..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-22T08:47:20.000Z"}],["meta",{"property":"article:author","content":"CrabSAMA"}],["meta",{"property":"article:tag","content":"Lit"}],["meta",{"property":"article:published_time","content":"2023-06-14T05:43:58.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-22T08:47:20.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Lit Element\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-06-14T05:43:58.000Z\\",\\"dateModified\\":\\"2024-08-22T08:47:20.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CrabSAMA\\",\\"url\\":\\"https://crabsama.github.io/CrabSAMA-Blog\\"}]}"]]},"headers":[{"level":2,"title":"Vue 中使用 Web Componment 传参","slug":"vue-中使用-web-componment-传参","link":"#vue-中使用-web-componment-传参","children":[]},{"level":2,"title":"@property 和 @state 的区别","slug":"property-和-state-的区别","link":"#property-和-state-的区别","children":[]},{"level":2,"title":"watch 变量变更","slug":"watch-变量变更","link":"#watch-变量变更","children":[]},{"level":2,"title":"生命周期","slug":"生命周期","link":"#生命周期","children":[]},{"level":2,"title":"lit 中使用 unocss","slug":"lit-中使用-unocss","link":"#lit-中使用-unocss","children":[]},{"level":2,"title":"Ref 引用","slug":"ref-引用","link":"#ref-引用","children":[]},{"level":2,"title":"直接渲染 html 字符串","slug":"直接渲染-html-字符串","link":"#直接渲染-html-字符串","children":[]},{"level":2,"title":"Computed 计算属性","slug":"computed-计算属性","link":"#computed-计算属性","children":[]},{"level":2,"title":"样式问题","slug":"样式问题","link":"#样式问题","children":[]},{"level":2,"title":"与 omi 框架对比","slug":"与-omi-框架对比","link":"#与-omi-框架对比","children":[]}],"git":{"createdTime":1724315850000,"updatedTime":1724316440000,"contributors":[{"name":"CrabSAMA","email":"71915282@qq.com","commits":2}]},"readingTime":{"minutes":5.23,"words":1570},"filePathRelative":"学习笔记/lit-element.md","localizedDate":"2023年6月14日","excerpt":"\\n<h2>Vue 中使用 Web Componment 传参</h2>\\n<blockquote>\\n<p><a href=\\"https://cn.vuejs.org/guide/extras/web-components.html#using-custom-elements-in-vue\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">在 Vue 中使用自定义元素</a></p>\\n</blockquote>\\n<p>针对基础非响应变量，一般可以直接通过 v-bind 方式传入；但如果是复杂数据类型或者响应变量，直接传入会导致响应式更新失效、数据传入失败等问题。建议始终使用 <code>.prop</code> 修饰符来进行传参，保证数据可以正确传入到组件中。</p>","autoDesc":true}');export{d as comp,k as data};
