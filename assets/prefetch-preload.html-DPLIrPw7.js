import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as s,o as r,c as p,a as e,b as a,d as n,e as c}from"./app-D1nyDd9a.js";const l={},d={href:"https://www.nowcoder.com/test/question/done?tid=35895019&qid=643152#summary",target:"_blank",rel:"noopener noreferrer"},i=e("br",null,null,-1),u={href:"https://zhuanlan.zhihu.com/p/48521680",target:"_blank",rel:"noopener noreferrer"},h=c(`<h2 id="preload-提前加载" tabindex="-1"><a class="header-anchor" href="#preload-提前加载"><span><strong>preload 提前加载</strong></span></a></h2><p><code>preload</code>顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用时立即执行，无需等待网络的消耗。<br><strong>当浏览器解析到这行代码就会去加载 href 中对应的资源</strong>，但不执行，待到真正使用到的时候再执行。</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token comment">&lt;!-- 使用 link 标签静态标记需要预加载的资源 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/path/to/style.css<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>style<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="prefetch-预判加载" tabindex="-1"><a class="header-anchor" href="#prefetch-预判加载"><span><strong>prefetch 预判加载</strong></span></a></h2><p><code>prefetch</code> 跟 <code>preload</code> 不同，它的作用是告诉浏览器未来可能会使用到的某个资源，<strong>浏览器就会在闲时去加载对应的资源</strong>，若能预测到用户端的行为，比如懒加载，点击到其他页面等则相当于提前预加载了需要的资源。</p><div class="language-html line-numbers-mode" data-ext="html" data-title="html"><pre class="language-html"><code><span class="token comment">&lt;!-- link 模式 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/path/to/style.css<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>style<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="更多细节点" tabindex="-1"><a class="header-anchor" href="#更多细节点"><span><strong>更多细节点</strong></span></a></h2><p>当一个资源被 <code>preload</code> 或者 <code>prefetch</code> 获取后，它将被放在内存缓存中等待被使用，如果资源位存在有效的缓存击中（如 <code>cache-control</code> 或 <code>max-age</code>），它将被存储在 <code>HTTP</code> 缓存中可以被不同页面所使用。<br> 正确使用 <code>preload</code>/<code>prefetch</code> 不会造成二次下载，也就说：<strong>当页面上使用到这个资源时候 <code>preload</code> 资源还没下载完，这时候不会造成二次下载，会等待第一次下载并执行脚本</strong>。<br><strong>对于 <code>preload</code> 来说，一旦页面关闭了，它就会立即停止 <code>preload</code> 获取资源，而对于 <code>prefetch</code> 资源，即使页面关闭，<code>prefetch</code> 发起的请求仍会进行不会中断。</strong></p><p><strong>preload</strong> 是告诉浏览器页面必定需要的资源，浏览器<strong>一定会加载</strong>这些资源，而 <strong><code>prefetch</code></strong> 是告诉浏览器页面可能需要的资源，浏览器<strong>不一定会加载</strong>这些资源。所以建议：对于当前页面很有必要的资源使用 <code>preload</code>，对于可能在将来的页面中使用的资源使用 <code>prefetch</code>。</p>`,9);function m(g,f){const t=s("ExternalLinkIcon");return r(),p("div",null,[e("p",null,[e("a",d,[a("牛客真题"),n(t)]),i,e("a",u,[a("知乎解析"),n(t)])]),h])}const _=o(l,[["render",m],["__file","prefetch-preload.html.vue"]]),v=JSON.parse('{"path":"/HTML/prefetch-preload.html","title":"prefetch和preload","lang":"zh-CN","frontmatter":{"title":"prefetch和preload","date":"2020-08-13T03:33:02.000Z","category":["前端开发"],"tag":["HTML","性能优化"],"description":"牛客真题 知乎解析 preload 提前加载 preload顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用时立即执行，无需等待网络的消耗。 当浏览器解析到这行代码就会去加载 href 中对应的资源，但不执行，待到真正使用到的时候再执行。 prefetch 预判加载 prefetch 跟 preload 不同...","head":[["meta",{"property":"og:url","content":"https://crabsama.github.io/CrabSAMA-Blog/CrabSAMA-Blog/HTML/prefetch-preload.html"}],["meta",{"property":"og:site_name","content":"CrabSAMA · 笔记"}],["meta",{"property":"og:title","content":"prefetch和preload"}],["meta",{"property":"og:description","content":"牛客真题 知乎解析 preload 提前加载 preload顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用时立即执行，无需等待网络的消耗。 当浏览器解析到这行代码就会去加载 href 中对应的资源，但不执行，待到真正使用到的时候再执行。 prefetch 预判加载 prefetch 跟 preload 不同..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-18T04:29:56.000Z"}],["meta",{"property":"article:author","content":"CrabSAMA"}],["meta",{"property":"article:tag","content":"HTML"}],["meta",{"property":"article:tag","content":"性能优化"}],["meta",{"property":"article:published_time","content":"2020-08-13T03:33:02.000Z"}],["meta",{"property":"article:modified_time","content":"2023-03-18T04:29:56.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"prefetch和preload\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-08-13T03:33:02.000Z\\",\\"dateModified\\":\\"2023-03-18T04:29:56.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CrabSAMA\\",\\"url\\":\\"https://crabsama.github.io/CrabSAMA-Blog\\"}]}"]]},"headers":[{"level":2,"title":"preload 提前加载","slug":"preload-提前加载","link":"#preload-提前加载","children":[]},{"level":2,"title":"prefetch 预判加载","slug":"prefetch-预判加载","link":"#prefetch-预判加载","children":[]},{"level":2,"title":"更多细节点","slug":"更多细节点","link":"#更多细节点","children":[]}],"git":{"createdTime":1679071923000,"updatedTime":1679113796000,"contributors":[{"name":"CrabSAMA","email":"71915282@qq.com","commits":2}]},"readingTime":{"minutes":1.84,"words":551},"filePathRelative":"HTML/prefetch-preload.md","localizedDate":"2020年8月13日","excerpt":"<p><a href=\\"https://www.nowcoder.com/test/question/done?tid=35895019&amp;qid=643152#summary\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">牛客真题</a><br>\\n<a href=\\"https://zhuanlan.zhihu.com/p/48521680\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">知乎解析</a></p>\\n<h2><strong>preload 提前加载</strong></h2>\\n<p><code>preload</code>顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用时立即执行，无需等待网络的消耗。<br>\\n<strong>当浏览器解析到这行代码就会去加载 href 中对应的资源</strong>，但不执行，待到真正使用到的时候再执行。</p>","autoDesc":true}');export{_ as comp,v as data};
