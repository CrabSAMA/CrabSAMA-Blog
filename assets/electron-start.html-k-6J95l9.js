import{_ as i,c as s,i as t,o as a}from"./app-BS7W8Gul.js";const n={};function l(r,e){return a(),s("div",null,e[0]||(e[0]=[t(`<h1 id="electron-初体验" tabindex="-1"><a class="header-anchor" href="#electron-初体验"><span>electron 初体验</span></a></h1><h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景"><span>背景</span></a></h2><p>在搭建基于 vuepress 的博客时，由于框架是基于 markdown 中的 frontmatter 来获取元数据，现在文章数量大，杂糅着不规范的 frontmatter，有些甚至没有写 frontmatter，因此下意识就想写一个可视化的 frontmatter 编辑器。</p><p>由于这里面需要文件读写等操作系统权限，使用 web 应用会捉襟见肘，因此第一时间想到的就是使用 electron 来实现，顺便也可以实践一下 electron。</p><h2 id="架构模型" tabindex="-1"><a class="header-anchor" href="#架构模型"><span>架构模型</span></a></h2><h3 id="主进程" tabindex="-1"><a class="header-anchor" href="#主进程"><span>主进程</span></a></h3><p>每个 electron 应用都有一个单一的主进程，作为整个应用程序的入口。主进程运行在 node.js 环境中，意味着它具有 <code>require</code> 模块和使用所有 node.js api 的能力。</p><p>主进程一般做的事情就是使用 <code>BrowserWidnow</code> 模块创建和管理应用程序窗口，这里面一般放着我们实际的 Web 应用。</p><h3 id="渲染器进程" tabindex="-1"><a class="header-anchor" href="#渲染器进程"><span>渲染器进程</span></a></h3><p>每个 electron 应用都会为打开的 <code>BrowserWindow</code> 生成一个单独的渲染器进程。由于渲染器的性质，导致了它无权访问 node.js 环境相关的 api，如果渲染器进程想与 node.js 和 electron 的原生桌面功能进行交互的话，就需要用到<strong>进程间通信</strong>的知识了。</p><h3 id="preload-脚本" tabindex="-1"><a class="header-anchor" href="#preload-脚本"><span>Preload 脚本</span></a></h3><p>预加载（preload）脚本包含了那些执行于渲染器进程中，且先于网页内容开始加载的代码 。 这些脚本虽运行于渲染器的环境中，却因能访问 Node.js API 而拥有了更多的权限。</p><p>Preload 脚本与渲染器共享着一个全局 <code>window</code> 对象，但我们不能直接从中附加任何变动到 <code>window</code> 上，因为这默认存在语境隔离（Context Isolation）的限制，这避免泄露任何特权相关的 API 到网页内容代码中。</p><p>取而代之，我们要使用 <code>contextBridge</code> 模块来交互：</p><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" data-title="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// preload.ts</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">import</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">contextBridge</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;electron&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">contextBridge</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">exposeInMainWorld</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;electronAPI&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // something...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" data-title="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// renderer.ts</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">console</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">window</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">electronAPI</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// =&gt; { something... }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般来说，我们会通过在这里面注入一些方法，使渲染层可以通过消息通信的方式调用主进程的方法。</p><h3 id="效率进程" tabindex="-1"><a class="header-anchor" href="#效率进程"><span>效率进程</span></a></h3><p>类似 webworker 的概念，可以 fork 一些子线程来做一些计算密集型的任务。</p><h2 id="进程间通信" tabindex="-1"><a class="header-anchor" href="#进程间通信"><span>进程间通信</span></a></h2><p>进程间通信（IPC）是 electron 中重要的一个概念，由于 electron 的多进程机制，导致各进程间的通信必须依赖 IPC，例如渲染器进程想调用 electron api 或者主进程触发页面上的一些变更，都需要 IPC 帮忙。</p><p>electron 的 IPC 通过 <code>ipcMain</code> 和 <code>ipcRender</code> 模块作为通信的通道。一般我们的通信分成单向和双向，单向一般指不要求返回信息，双向一般指调用后需要等待返回的信息。</p><h3 id="渲染器进程到主进程-单向" tabindex="-1"><a class="header-anchor" href="#渲染器进程到主进程-单向"><span>渲染器进程到主进程（单向）</span></a></h3><ol><li>主进程 <code>ipcMain.on</code> 监听事件</li><li>通过 preload 脚本暴露 <code>ipcRenderer.send</code></li></ol><h3 id="渲染器进程到主进程-双向" tabindex="-1"><a class="header-anchor" href="#渲染器进程到主进程-双向"><span>渲染器进程到主进程（双向）</span></a></h3><ol><li>主进程 <code>ipcMain.handler</code> 监听事件</li><li>通过 preload 脚本暴露 <code>ipcRenderer.invoke</code></li></ol><h3 id="主进程到渲染器进程" tabindex="-1"><a class="header-anchor" href="#主进程到渲染器进程"><span>主进程到渲染器进程</span></a></h3><ol><li>主进程使用 <code>webContents</code> 模块发送消息</li><li>通过 preload 脚本暴露 <code>ipcRenderer.on</code></li><li>渲染器进程使用 <code>ipcRenderer.on</code> 监听消息</li><li>（可选）在渲染器进程中，使用 event 参数的 sender 对象将回复发送回主进程，此时主进程需要监听对应的事件</li></ol><h2 id="经验" tabindex="-1"><a class="header-anchor" href="#经验"><span>经验</span></a></h2><h3 id="vite-在-electron-中的使用" tabindex="-1"><a class="header-anchor" href="#vite-在-electron-中的使用"><span>vite 在 electron 中的使用</span></a></h3><p>使用 plugin：<code>vite-plugin-electron</code></p><ul><li>electron 尚未支持 <code>&quot;type&quot;: &quot;module&quot;</code>，因此需要将 vite 默认的 module 去掉。</li><li>默认会报找不到 &quot;path&quot; 模块，安装一个 <code>@types/node</code> 即可。</li></ul><h3 id="electron-选择文件-文件夹" tabindex="-1"><a class="header-anchor" href="#electron-选择文件-文件夹"><span>electron 选择文件/文件夹</span></a></h3><p>使用 electron 原生的 <code>dialog</code> 模块。</p><h3 id="typescript-扩展-window-全局对象" tabindex="-1"><a class="header-anchor" href="#typescript-扩展-window-全局对象"><span>typescript 扩展 window 全局对象</span></a></h3><p>创建一个 <code>renderer.d.ts</code> 类型声明文件，并且全局扩展 <code>Window</code> 接口。</p><div class="language-typescript line-numbers-mode" data-highlighter="shiki" data-ext="typescript" data-title="typescript" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> electronAPI</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  openSelectDirDialog</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> () </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">void</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">  getFrontMatter</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">markdownPath</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#0184BC;--shiki-dark:#E5C07B;"> string</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=&gt;</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Promise</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#E5C07B;">matter</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">GrayMatterFile</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">string</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;&gt;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Window</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">  electronAPI</span><span style="--shiki-light:#0184BC;--shiki-dark:#ABB2BF;">:</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> electronAPI</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就可以保证我们在编写渲染进程的代码时，typescript 编译器将会判断出来正确的类型。</p><h3 id="electron-pnpm-打包报错" tabindex="-1"><a class="header-anchor" href="#electron-pnpm-打包报错"><span>electron + pnpm 打包报错</span></a></h3><blockquote><p><a href="https://github.com/electron-userland/electron-builder/issues/6289#issuecomment-1042620422" target="_blank" rel="noopener noreferrer">github issue</a></p></blockquote><p>如果要在 pnpm 下打包 electron 应用，需要在 .npmrc 中进行配置，使 pnpm 不使用软链接的方式进行包管理，才能使 electron 获取到对应的 npm 包。</p><h3 id="react-更改数组中某一项" tabindex="-1"><a class="header-anchor" href="#react-更改数组中某一项"><span>react 更改数组中某一项</span></a></h3><p>使用 ... 拓展运算符将原来的值拷贝一份，然后在新数据上操作，操作完成后调用 setState 更新状态。</p><h3 id="typescript-索引类型" tabindex="-1"><a class="header-anchor" href="#typescript-索引类型"><span>typescript 索引类型</span></a></h3><p>TODO</p><h3 id="文本标签遇到-n-换行" tabindex="-1"><a class="header-anchor" href="#文本标签遇到-n-换行"><span>文本标签遇到 /n 换行</span></a></h3><p>css 属性 <code>white-space: pre-line</code></p><h3 id="windows-下隐藏菜单栏" tabindex="-1"><a class="header-anchor" href="#windows-下隐藏菜单栏"><span>Windows 下隐藏菜单栏</span></a></h3><p><code>win.removeMenu()</code></p>`,49)]))}const h=i(n,[["render",l],["__file","electron-start.html.vue"]]),d=JSON.parse('{"path":"/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/electron-start.html","title":"electron 初体验","lang":"zh-CN","frontmatter":{"title":"electron 初体验","date":"2023-03-20T02:49:55.000Z","category":["日志随笔"],"tag":["Electron"],"description":"electron 初体验 背景 在搭建基于 vuepress 的博客时，由于框架是基于 markdown 中的 frontmatter 来获取元数据，现在文章数量大，杂糅着不规范的 frontmatter，有些甚至没有写 frontmatter，因此下意识就想写一个可视化的 frontmatter 编辑器。 由于这里面需要文件读写等操作系统权限，使用 ...","head":[["meta",{"property":"og:url","content":"https://crabsama.github.io/CrabSAMA-Blog/CrabSAMA-Blog/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/electron-start.html"}],["meta",{"property":"og:site_name","content":"CrabSAMA · 笔记"}],["meta",{"property":"og:title","content":"electron 初体验"}],["meta",{"property":"og:description","content":"electron 初体验 背景 在搭建基于 vuepress 的博客时，由于框架是基于 markdown 中的 frontmatter 来获取元数据，现在文章数量大，杂糅着不规范的 frontmatter，有些甚至没有写 frontmatter，因此下意识就想写一个可视化的 frontmatter 编辑器。 由于这里面需要文件读写等操作系统权限，使用 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-09-29T07:33:27.000Z"}],["meta",{"property":"article:author","content":"CrabSAMA"}],["meta",{"property":"article:tag","content":"Electron"}],["meta",{"property":"article:published_time","content":"2023-03-20T02:49:55.000Z"}],["meta",{"property":"article:modified_time","content":"2024-09-29T07:33:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"electron 初体验\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-03-20T02:49:55.000Z\\",\\"dateModified\\":\\"2024-09-29T07:33:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"CrabSAMA\\",\\"url\\":\\"https://crabsama.github.io/CrabSAMA-Blog\\"}]}"]]},"headers":[{"level":2,"title":"背景","slug":"背景","link":"#背景","children":[]},{"level":2,"title":"架构模型","slug":"架构模型","link":"#架构模型","children":[{"level":3,"title":"主进程","slug":"主进程","link":"#主进程","children":[]},{"level":3,"title":"渲染器进程","slug":"渲染器进程","link":"#渲染器进程","children":[]},{"level":3,"title":"Preload 脚本","slug":"preload-脚本","link":"#preload-脚本","children":[]},{"level":3,"title":"效率进程","slug":"效率进程","link":"#效率进程","children":[]}]},{"level":2,"title":"进程间通信","slug":"进程间通信","link":"#进程间通信","children":[{"level":3,"title":"渲染器进程到主进程（单向）","slug":"渲染器进程到主进程-单向","link":"#渲染器进程到主进程-单向","children":[]},{"level":3,"title":"渲染器进程到主进程（双向）","slug":"渲染器进程到主进程-双向","link":"#渲染器进程到主进程-双向","children":[]},{"level":3,"title":"主进程到渲染器进程","slug":"主进程到渲染器进程","link":"#主进程到渲染器进程","children":[]}]},{"level":2,"title":"经验","slug":"经验","link":"#经验","children":[{"level":3,"title":"vite 在 electron 中的使用","slug":"vite-在-electron-中的使用","link":"#vite-在-electron-中的使用","children":[]},{"level":3,"title":"electron 选择文件/文件夹","slug":"electron-选择文件-文件夹","link":"#electron-选择文件-文件夹","children":[]},{"level":3,"title":"typescript 扩展 window 全局对象","slug":"typescript-扩展-window-全局对象","link":"#typescript-扩展-window-全局对象","children":[]},{"level":3,"title":"electron + pnpm 打包报错","slug":"electron-pnpm-打包报错","link":"#electron-pnpm-打包报错","children":[]},{"level":3,"title":"react 更改数组中某一项","slug":"react-更改数组中某一项","link":"#react-更改数组中某一项","children":[]},{"level":3,"title":"typescript 索引类型","slug":"typescript-索引类型","link":"#typescript-索引类型","children":[]},{"level":3,"title":"文本标签遇到 /n 换行","slug":"文本标签遇到-n-换行","link":"#文本标签遇到-n-换行","children":[]},{"level":3,"title":"Windows 下隐藏菜单栏","slug":"windows-下隐藏菜单栏","link":"#windows-下隐藏菜单栏","children":[]}]}],"git":{"createdTime":1679297432000,"updatedTime":1727595207000,"contributors":[{"name":"CrabSAMA","email":"71915282@qq.com","commits":4}]},"readingTime":{"minutes":3.86,"words":1158},"filePathRelative":"日志随笔/electron-start.md","localizedDate":"2023年3月20日","excerpt":"\\n<h2>背景</h2>\\n<p>在搭建基于 vuepress 的博客时，由于框架是基于 markdown 中的 frontmatter 来获取元数据，现在文章数量大，杂糅着不规范的 frontmatter，有些甚至没有写 frontmatter，因此下意识就想写一个可视化的 frontmatter 编辑器。</p>\\n<p>由于这里面需要文件读写等操作系统权限，使用 web 应用会捉襟见肘，因此第一时间想到的就是使用 electron 来实现，顺便也可以实践一下 electron。</p>\\n<h2>架构模型</h2>\\n<h3>主进程</h3>\\n<p>每个 electron 应用都有一个单一的主进程，作为整个应用程序的入口。主进程运行在 node.js 环境中，意味着它具有 <code>require</code> 模块和使用所有 node.js api 的能力。</p>","autoDesc":true}');export{h as comp,d as data};
