import{_ as t,W as o,X as c,Y as a,Z as e,a0 as s,a1 as p,C as r}from"./framework-474f8844.js";const l={},d={href:"https://www.nowcoder.com/test/question/done?tid=35895019&qid=643152#summary",target:"_blank",rel:"noopener noreferrer"},u={href:"https://zhuanlan.zhihu.com/p/48521680",target:"_blank",rel:"noopener noreferrer"},i=p(`<h2 id="preload-提前加载" tabindex="-1"><a class="header-anchor" href="#preload-提前加载" aria-hidden="true">#</a> <strong>preload 提前加载</strong></h2><p><code>preload</code>顾名思义就是一种预加载的方式，它通过声明向浏览器声明一个需要提交加载的资源，当资源真正被使用时立即执行，无需等待网络的消耗。 <strong>当浏览器解析到这行代码就会去加载 href 中对应的资源</strong>，但不执行，待到真正使用到的时候再执行。</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token comment">&lt;!-- 使用 link 标签静态标记需要预加载的资源 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>preload<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/path/to/style.css<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>style<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="prefetch-预判加载" tabindex="-1"><a class="header-anchor" href="#prefetch-预判加载" aria-hidden="true">#</a> <strong>prefetch 预判加载</strong></h2><p><code>prefetch</code> 跟 <code>preload</code> 不同，它的作用是告诉浏览器未来可能会使用到的某个资源，<strong>浏览器就会在闲时去加载对应的资源</strong>，若能预测到用户端的行为，比如懒加载，点击到其他页面等则相当于提前预加载了需要的资源。</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token comment">&lt;!-- link 模式 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>prefetch<span class="token punctuation">&quot;</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>/path/to/style.css<span class="token punctuation">&quot;</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>style<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="更多细节点" tabindex="-1"><a class="header-anchor" href="#更多细节点" aria-hidden="true">#</a> <strong>更多细节点</strong></h2><p>当一个资源被 <code>preload</code> 或者 <code>prefetch</code> 获取后，它将被放在内存缓存中等待被使用，如果资源位存在有效的缓存击中（如 <code>cache-control</code> 或 <code>max-age</code>），它将被存储在 <code>HTTP</code> 缓存中可以被不同页面所使用。 正确使用 <code>preload</code>/<code>prefetch</code> 不会造成二次下载，也就说：<strong>当页面上使用到这个资源时候 <code>preload</code> 资源还没下载完，这时候不会造成二次下载，会等待第一次下载并执行脚本</strong>。 <strong>对于 <code>preload</code> 来说，一旦页面关闭了，它就会立即停止 <code>preload</code> 获取资源，而对于 <code>prefetch</code> 资源，即使页面关闭，<code>prefetch</code> 发起的请求仍会进行不会中断。</strong></p><p><strong>preload</strong> 是告诉浏览器页面必定需要的资源，浏览器<strong>一定会加载</strong>这些资源，而 <strong><code>prefetch</code></strong> 是告诉浏览器页面可能需要的资源，浏览器<strong>不一定会加载</strong>这些资源。所以建议：对于当前页面很有必要的资源使用 <code>preload</code>，对于可能在将来的页面中使用的资源使用 <code>prefetch</code>。</p>`,9);function h(k,g){const n=r("ExternalLinkIcon");return o(),c("div",null,[a("p",null,[a("a",d,[e("牛客真题"),s(n)]),a("a",u,[e("知乎解析"),s(n)])]),i])}const f=t(l,[["render",h],["__file","prefetch-preload.html.vue"]]);export{f as default};
