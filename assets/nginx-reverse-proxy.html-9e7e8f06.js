import{_ as c,W as a,X as d,Y as n,Z as e,a0 as s,a1 as t,C as i}from"./framework-474f8844.js";const r={},p=t(`<h2 id="背景" tabindex="-1"><a class="header-anchor" href="#背景" aria-hidden="true">#</a> 背景</h2><p>在日常开发中，一般 <code>Vue</code> 有两种方式解决跨域问题，一是使用 <code>Vue dev server</code> 中的 <code>proxyTable</code> 选项，搭建本地的反向代理服务器，解决跨域；二是与后端小伙伴沟通，让其允许跨域。</p><p>但是这是在开发过程中，如果后端小伙伴不想开放跨域，然而我们确实是前后端分离部署会触发到同源策略的话，这下就需要我们搭建基于服务器上的反向代理。</p><p>在此之前，我们需要先搞明白一个概念，跨域安全策略是浏览器的一种安全策略，它会将不属于同一个源下的请求 block 掉，其实可以理解成，请求已经发送出去并且服务器已经做出响应，只是被浏览器这个中间人拦截下来了，因为它觉得这是不安全的请求。</p><p>既然知道了这是浏览器的一种策略，那么在之前疑惑的一个问题也顺理成章地得到回答了：<strong>为什么使用</strong> <strong><code>postman</code></strong> **等工具请求接口不会触发跨域？**很明显，因为这些工具不是浏览器环境，只有在浏览器环境下才会触发跨域，服务器与服务器之间请求是不会触发跨域的。</p><p>现在流行的 <code>html</code> 服务器有 <code>apache</code>、<code>nginx</code> 等，这次就以 <code>nginx</code> 为例，说明一下如何搭建反向代理，可以解决跨域问题、由于 <code>chrome</code> 更新后安全策略提高导致的 same-site: Lax 问题等。</p><h2 id="实操" tabindex="-1"><a class="header-anchor" href="#实操" aria-hidden="true">#</a> 实操</h2><p>我们需要找到 <code>nginx</code> 的安装目录，进入其 <code>conf</code> 文件夹，打开 <code>nginx.conf</code> 配置文件。</p><p>找到 <code>location / { … }</code> 这一行，这里是代理默认请求到 <code>index.html</code> ，很符合 <code>Vue</code> 打包出来的 <code>SPA</code> 项目逻辑（一切请求指向 <code>index.html</code>，剩下路由等问题由 <code>Vue</code> 进行处理）。那么我们想要做的是，将 api 请求重定向到后端的服务器，因此这个代理是应该在最上层的，所以我们需要在刚刚的那一行上面，添加这样的配置：</p><div class="language-nginx line-numbers-mode" data-ext="nginx"><pre class="language-nginx"><code><span class="token directive"><span class="token keyword">location</span> /api</span> <span class="token punctuation">{</span>
   <span class="token directive"><span class="token keyword">proxy_pass</span> http://xxx:8080</span><span class="token punctuation">;</span>  <span class="token comment">#node api server 即需要代理的IP地址</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的配置意思是，将请求到 <code>localhost/api/…</code> 的所有请求，转发到 <code>proxy_pass</code> 这个地址去，并且由 <code>nginx</code> 获取到响应后的结果进行返回。在做完这个之后，其实反向代理已经搭建完成了。还有其他一系列的一些其他配置，可以给请求头 / 响应头添加一些便于交流的属性，这个可以在 <code>nginx</code> 的配置文档中看到，此处就不做描述，有兴趣可以了解一下。</p>`,11),l={href:"http://xxx:8080/api/login%EF%BC%89",target:"_blank",rel:"noopener noreferrer"},x=n("code",null,"/api/login",-1),h=n("code",null,"localhost/api/login",-1),u=n("code",null,"nginx",-1);function _(g,m){const o=i("ExternalLinkIcon");return a(),d("div",null,[p,n("p",null,[e("前端在搭建完成后，还需要将原本项目中的绝对地址的请求（eg: "),n("a",l,[e("http://xxx:8080/api/login）"),s(o)]),e(" 转换为相对地址的请求（即 "),x,e("，请求到 "),h,e("），这样 "),u,e(" 就会成功代理到我们的请求并转发到后端服务器。")])])}const k=c(r,[["render",_],["__file","nginx-reverse-proxy.html.vue"]]);export{k as default};
